Index: src/iparo/LinkingStrategy.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nfrom abc import abstractmethod, ABC\r\nfrom datetime import timedelta\r\nfrom math import floor\r\n\r\nfrom iparo.IPARODateFormat import IPARODateFormat\r\nfrom iparo.IPAROLink import IPAROLink\r\nfrom iparo.IPAROLinkFactory import IPAROLinkFactory\r\nfrom iparo.IPFS import ipfs, Mode\r\nfrom iparo.IPNS import ipns\r\n\r\n\r\n# Make package/renaming with __init__ file\r\n\r\nclass LinkingStrategy(ABC):\r\n    \"\"\"\r\n    The linking strategy determines how the new IPARO is to be linked. The IPARO\r\n    object is first linked using the linking strategy, created (with the links),\r\n    and then finally stored.\r\n    \"\"\"\r\n\r\n    @abstractmethod\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        pass\r\n\r\n\r\nclass SingleStrategy(LinkingStrategy):\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_cid = ipns.get_latest_cid(url)\r\n        return {IPAROLinkFactory.from_cid(latest_cid)}\r\n\r\n\r\nclass ComprehensiveStrategy(LinkingStrategy):\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_node_links, latest_link, _ = IPAROLinkFactory.get_latest_node_links(url)\r\n        latest_node_links.add(latest_link)\r\n\r\n        return latest_node_links\r\n\r\n\r\nclass KPreviousStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, k: int):\r\n        self.k = k\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        linked_iparos, latest_link, latest_iparo = IPAROLinkFactory.get_latest_node_links(url)\r\n\r\n        seq_num_to_drop = max(latest_link.seq_num - self.k, 0)\r\n        if seq_num_to_drop > 0:\r\n            iparo_link_to_drop = ipfs.retrieve_nth_iparo(seq_num_to_drop, latest_link)\r\n            linked_iparos.remove(iparo_link_to_drop)\r\n\r\n        return linked_iparos\r\n\r\n\r\nclass PreviousStrategy(KPreviousStrategy):\r\n\r\n    def __init__(self):\r\n        super().__init__(1)\r\n\r\n\r\nclass KRandomStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, k: int):\r\n        self.k = k\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_node_links, latest_link, latest_iparo = IPAROLinkFactory.get_latest_node_links(url)\r\n\r\n        num_nodes = latest_link.seq_num\r\n        if num_nodes <= self.k:\r\n            latest_node_links.add(latest_link)\r\n            return latest_node_links\r\n        else:\r\n            # K random sequence numbers from 1 to n-1, n = latest sequence number\r\n            candidate_seq_nums = set(random.sample(range(1, num_nodes), min(self.k, num_nodes - 1)))\r\n            candidate_seq_nums.add(0)\r\n            links = IPAROLinkFactory.from_indices(latest_link, set(candidate_seq_nums))\r\n        links.add(latest_link)\r\n        return links\r\n\r\n\r\nclass SequentialExponentialStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, k: float):\r\n        self.k = k\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_link = ipfs.get_latest_link(url)\r\n        node_num = latest_link.seq_num\r\n        indices: set[int] = {0, node_num}\r\n        index = 1.0\r\n        while index < node_num + 1:\r\n            indices.add(node_num - floor(index - 1))\r\n            index *= self.k\r\n        links = IPAROLinkFactory.from_indices(latest_link, indices)\r\n        return links\r\n\r\n\r\nclass SequentialUniformNPriorStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, n: int):\r\n        self.n = n\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_link, latest_iparo = IPAROLinkFactory.get_link_to_latest_node(url)\r\n        indices: set[int] = {latest_iparo.seq_num * i // (self.n + 1) for i in range(self.n + 2)}\r\n        return IPAROLinkFactory.from_indices(latest_link, indices)\r\n\r\n\r\nclass SequentialSMaxGapStrategy(LinkingStrategy):\r\n\r\n    # s: the number of hops allowed between linked nodes.\r\n    def __init__(self, s: int):\r\n        self.s = s\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n\r\n        # Sequentially add nodes with no more than S hops between them\r\n        start_seq_num = latest_link.seq_num - self.s\r\n\r\n        # range(start, 0, -s) -> From start to 0 (exclusive), going down in step of size s.\r\n        node_indices = set(range(start_seq_num, 0, -self.s))\r\n        links = IPAROLinkFactory.from_indices(latest_link, node_indices)\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n\r\n        return links\r\n\r\n\r\nclass TemporallyUniformStrategy(LinkingStrategy):\r\n    def __init__(self, n: int):\r\n        self.n = n  # Number of uniformly distributed links to create\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        # Get Latest Link and Latest CID in one fell swoop\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n        time_window = IPARODateFormat.diff(latest_link.timestamp, first_link.timestamp)\r\n        first_ts = first_link.timestamp\r\n        # Adds nodes sequenced as 1, 2, ..., n-1\r\n        timestamps = set(IPARODateFormat.add_timedeltas(first_ts,\r\n                                                        [i * time_window / self.n for i in range(1, self.n)]))\r\n        links, _ = IPAROLinkFactory.from_timestamps(latest_link, {first_link, latest_link}, timestamps)\r\n\r\n        # Add latest and first links.\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n\r\n        return links\r\n\r\n\r\nclass TemporallyMaxGapStrategy(LinkingStrategy):\r\n    def __init__(self, max_gap: timedelta):\r\n        self.max_gap = max_gap\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n        curr_link = latest_link\r\n        current_time = latest_link.timestamp\r\n        known_links = {first_link, latest_link}\r\n\r\n        links = set()\r\n        # Keep stepping back using max_gap\r\n        while curr_link.seq_num > 0:\r\n            current_time = IPARODateFormat.add_timedelta(current_time, -self.max_gap)\r\n            curr_link, known_links = ipfs.retrieve_closest_iparo(curr_link, known_links,\r\n                                                                 current_time, Mode.LATEST_BEFORE)\r\n            links.add(curr_link)\r\n\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n        return links\r\n\r\n\r\nclass TemporallyExponentialStrategy(LinkingStrategy):\r\n    def __init__(self, base: float, time_unit: timedelta):\r\n        self.base = base\r\n        self.time_unit = time_unit\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        # Assume num_nodes > 1\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n\r\n        # Exponential time gaps\r\n        gap = self.time_unit\r\n        time_window = IPARODateFormat.diff(latest_iparo.timestamp, first_link.timestamp)\r\n        gaps = []\r\n        while gap < time_window:\r\n            gaps.append(-gap)\r\n            gap *= self.base\r\n        gaps.reverse()\r\n\r\n        timestamps = IPARODateFormat.add_timedeltas(latest_iparo.timestamp, gaps)\r\n        links, _ = IPAROLinkFactory.from_timestamps(latest_link, {first_link, latest_link}, timestamps)\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n\r\n        return links\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/LinkingStrategy.py b/src/iparo/LinkingStrategy.py
--- a/src/iparo/LinkingStrategy.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/LinkingStrategy.py	(date 1744656337757)
@@ -89,8 +89,8 @@
         self.k = k
 
     def get_candidate_nodes(self, url: str) -> set[IPAROLink]:
-        latest_link = ipfs.get_latest_link(url)
-        node_num = latest_link.seq_num
+        latest_link, latest_iparo = IPAROLinkFactory.get_link_to_latest_node(url)
+        node_num = latest_iparo.seq_num
         indices: set[int] = {0, node_num}
         index = 1.0
         while index < node_num + 1:
Index: src/iparo/IPAROSimulation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.LinkingStrategy import *\r\n\r\nimport networkx as nx\r\n\r\nfrom iparo.VersionDensity import *\r\nfrom iparo.IPFS import ipfs\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\nclass IPAROSimulation:\r\n    \"\"\"\r\n    The class for the testing environment.\r\n    \"\"\"\r\n\r\n    def __init__(self, linking_strategy: LinkingStrategy, version_density: VersionDensity,\r\n                 version_volume: VersionVolume):\r\n        self.linking_strategy = linking_strategy\r\n        self.version_density = version_density\r\n        self.version_volume = version_volume\r\n\r\n        # Debug variables for testing.\r\n        self.ipfs_store_results: dict[str, int] = dict()\r\n        self.ipns_store_results: dict[str, int] = dict()\r\n        self.ipfs_retrieve_results: dict[str, int] = dict()\r\n        self.ipns_retrieve_results: dict[str, int] = dict()\r\n\r\n    def run(self, k: int, verbose=True):\r\n        \"\"\"\r\n        Sets up the testing environment for an IPARO simulation, and then\r\n        performs k random.\r\n        \"\"\"\r\n        nodes = self.version_density.get_iparos(self.version_volume)\r\n        # Link the IPAROs in the IPFS\r\n        for i, node in enumerate(nodes):\r\n            node.seq_num = i\r\n            try:\r\n                node.linked_iparos = self.linking_strategy.get_candidate_nodes(URL)\r\n            except IPARONotFoundException:\r\n                node.linked_iparos = set()\r\n            cid = ipfs.store(node)\r\n            ipns.update(URL, cid)\r\n\r\n        self.ipfs_store_results = ipfs.get_counts()\r\n        self.ipns_store_results = ipns.get_counts()\r\n        if verbose:\r\n            IPAROSimulation.print_counts(\"Store\")\r\n        IPAROSimulation.reset()\r\n\r\n        # Get node number from latest CID\r\n        latest_cid = ipns.get_latest_cid(URL)\r\n        latest_node = ipfs.retrieve(latest_cid)\r\n        for i in range(k):\r\n            selected_index = random.randint(0, latest_node.seq_num - 1)\r\n\r\n            # The intent is to find separate numbers, where the numbers are not known until at runtime.\r\n            ipfs.retrieve_iparo_by_url_and_number(URL, selected_index)\r\n        if verbose:\r\n            IPAROSimulation.print_counts(\"Retrieve\")\r\n\r\n        self.ipfs_retrieve_results = ipfs.get_counts()\r\n        self.ipns_retrieve_results = ipns.get_counts()\r\n\r\n    @classmethod\r\n    def print_counts(cls, header: str):\r\n        \"\"\"\r\n        A tool that can be useful in debugging.\r\n        \"\"\"\r\n        print(header)\r\n        print(\"IPFS Counts:\")\r\n        print(ipfs.get_counts())\r\n        print(\"IPNS Counts:\")\r\n        print(ipns.get_counts())\r\n\r\n    def as_graph(self):\r\n        \"\"\"\r\n        Creates a DiGraph object out of the current nodes in the IPFS.\r\n        \"\"\"\r\n        # Do comprehensive\r\n        nx_graph = nx.DiGraph()\r\n        for iparo in ipfs.get_all_iparos(URL):\r\n            curr_num = iparo.seq_num\r\n            nx_graph.add_node(curr_num)\r\n            for link in iparo.linked_iparos:\r\n                nx_graph.add_edge(curr_num, link.seq_num)\r\n\r\n        return nx_graph\r\n\r\n    @classmethod\r\n    def reset(cls, reset_data=False):\r\n        \"\"\"Resets the counts (and optionally, the data) from the IPNS and IPFS.\"\"\"\r\n        if reset_data:\r\n            ipfs.reset_data()\r\n            ipns.reset_data()\r\n        ipfs.reset_counts()\r\n        ipns.reset_counts()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    linking_strategy = TemporallyUniformStrategy(2)\r\n    simulation = IPAROSimulation(linking_strategy=linking_strategy,\r\n                                 version_volume=VersionVolume.MEDIUM,\r\n                                 version_density=UniformVersionDensity())\r\n    simulation.run(100, verbose=False)\r\n    nx.draw_networkx(simulation.as_graph(), arrows=True)\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPAROSimulation.py b/src/iparo/IPAROSimulation.py
--- a/src/iparo/IPAROSimulation.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPAROSimulation.py	(date 1744656337685)
@@ -28,7 +28,7 @@
     def run(self, k: int, verbose=True):
         """
         Sets up the testing environment for an IPARO simulation, and then
-        performs k random.
+        performs k random-uniform retrievals.
         """
         nodes = self.version_density.get_iparos(self.version_volume)
         # Link the IPAROs in the IPFS
Index: test/IPFSTest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\r\n\r\nfrom IPAROTestConstants import *\r\nfrom IPAROTestHelpers import add_nodes, test_strategy, test_closest_iparo\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPAROLinkFactory import IPAROLinkFactory\r\nfrom iparo.IPFS import ipfs, Mode\r\nfrom iparo.IPNS import ipns\r\nfrom iparo.LinkingStrategy import SingleStrategy\r\n\r\ntimestamp = datetime.now()\r\n\r\n\r\nclass IPFSTest(unittest.TestCase):\r\n\r\n    def tearDown(self):\r\n        ipns.reset_data()\r\n        ipns.reset_counts()\r\n        ipfs.reset_data()\r\n        ipfs.reset_counts()\r\n\r\n    def test_ipfs_counters_should_be_zero_initially(self):\r\n        self.assertEqual(ipfs.retrieve_count, 0)\r\n        self.assertEqual(ipfs.store_count, 0)\r\n\r\n    def test_ipfs_should_initially_have_no_iparos(self):\r\n        self.assertDictEqual(ipfs.data, {})\r\n\r\n    def test_ipfs_should_store_one_iparo(self):\r\n        cid = ipfs.store(iparo1)\r\n        self.assertIn(cid, ipfs.data)\r\n\r\n    def test_ipfs_should_retrieve_iparos(self):\r\n        cid = ipfs.store(iparo1)\r\n        iparo = ipfs.retrieve(cid)\r\n        self.assertEqual(iparo, iparo1)\r\n\r\n    def test_ipfs_should_count_retrievals(self):\r\n        cid = ipfs.store(iparo1)\r\n        ipfs.retrieve(cid)\r\n        self.assertEqual(ipfs.retrieve_count, 1)\r\n\r\n    def test_ipfs_should_retrieve_iparos_twice(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        node1 = ipfs.retrieve(cid)\r\n        node2 = ipfs.retrieve(cid2)\r\n        self.assertEqual(node1, iparo1)\r\n        self.assertEqual(node2, iparo2)\r\n\r\n    # Note: The converse of the proposition implied by the test is not necessarily true.\r\n    # That is, different IPAROs can have the same CIDs, but the same IPARO cannot have\r\n    # two different CIDs. We can see this in more detail when we get there.\r\n    def test_different_cids_should_yield_different_iparos(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        node1 = ipfs.retrieve(cid)\r\n        node2 = ipfs.retrieve(cid2)\r\n        self.assertNotEqual(node1, node2)\r\n\r\n    def test_ipfs_should_update_retrieval_counts_twice(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        ipfs.retrieve(cid)\r\n        ipfs.retrieve(cid2)\r\n        self.assertEqual(ipfs.retrieve_count, 2)\r\n\r\n    def test_ipfs_should_store_two_iparos(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        self.assertIn(cid, ipfs.data)\r\n        self.assertIn(cid2, ipfs.data)\r\n\r\n    def test_ipfs_versions_should_initially_be_empty(self):\r\n        cids = ipfs.get_all_iparos(URL)\r\n        self.assertEqual(len(cids), 0)\r\n\r\n    def test_ipfs_versions_should_update_on_one_insert(self):\r\n        cid = ipfs.store(iparo1)\r\n        ipns.update(URL, cid)\r\n        cids = ipfs.get_all_iparos(URL)\r\n        self.assertEqual(len(cids), 1)\r\n\r\n    def test_ipfs_versions_should_update_on_two_inserts(self):\r\n        cid = ipfs.store(iparo1)\r\n        ipns.update(URL, cid)\r\n\r\n        iparo2.linked_iparos = {IPAROLinkFactory.from_cid_iparo(cid, iparo1)}\r\n        cid2 = ipfs.store(iparo2)\r\n        ipns.update(URL, cid2)\r\n        cids = {link.cid for link in ipfs.get_all_links(URL)}\r\n        self.assertSetEqual(cids, {cid, cid2})\r\n\r\n    def test_ipfs_should_retrieve_by_url_and_number(self):\r\n        iparos = add_nodes(3)\r\n\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 0)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[0])\r\n\r\n    def test_ipfs_should_retrieve_last_node(self):\r\n        iparos = add_nodes(3)\r\n\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 2)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[2])\r\n\r\n    def test_ipfs_should_retrieve_middle_node(self):\r\n        iparos = add_nodes(10)\r\n\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 5)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_retrieve_latest_time_before_target_timestamp_by_default(self):\r\n        iparos = add_nodes(100)\r\n\r\n        timestamp = datetime.strftime(time1 + timedelta(seconds=55), IPARODateFormat.DATE_FORMAT)\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, timestamp)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_raise_error_if_no_iparo_is_inserted_into_ipfs(self):\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_by_url_and_timestamp(URL, time1, Mode.CLOSEST))\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_by_url_and_timestamp(URL, time1,\r\n                                                                                             Mode.EARLIEST_AFTER))\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_by_url_and_timestamp(URL, time1))\r\n\r\n    def test_ipfs_should_retrieve_earliest_time_after_target_timestamp(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=51), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.EARLIEST_AFTER)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[6])\r\n\r\n    def test_ipfs_should_retrieve_target_timestamp_if_there_exists_a_cid_with_the_target_timestamp(self):\r\n        iparos = add_nodes(100)\r\n\r\n        time = datetime.strftime(time1 + timedelta(seconds=50), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link1 = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.EARLIEST_AFTER)\r\n        link2 = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        link3 = ipfs.retrieve_by_url_and_timestamp(URL, time)\r\n\r\n        links = {link1, link2, link3}\r\n        iparo = ipfs.retrieve(link1.cid)\r\n\r\n        self.assertEqual(iparo, iparos[5])\r\n        self.assertSetEqual(links, {link1})\r\n\r\n    def test_ipfs_should_retrieve_earlier_time_if_two_closest_timestamps_are_equally_distant(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=55), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_retrieve_earlier_time_if_closest_timestamp_is_earlier(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=54), IPARODateFormat.DATE_FORMAT)\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_retrieve_earlier_time_if_closest_timestamp_is_later(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=56), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[6])\r\n\r\n    def test_ipfs_should_retrieve_earliest_time_after_timestamp(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=54), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n\r\nclass IPAROLinkFactoryTest(unittest.TestCase):\r\n\r\n    def setUp(self):\r\n        # Will produce 100 nodes, each uniformly distributed with interval = 1 second.\r\n        test_strategy(SingleStrategy())\r\n\r\n    def test_can_throw_when_iparo_seq_num_is_less_than_input_seq_num(self):\r\n        cid = ipns.get_latest_cid(URL)\r\n        iparo = ipfs.retrieve(cid)\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_nth_iparo(100, iparo))\r\n\r\n    def test_can_get_latest_iparo_if_iparo_seq_num_is_equal_to_input_seq_num(self):\r\n        cid = ipns.get_latest_cid(URL)\r\n        iparo = ipfs.retrieve(cid)\r\n        link = IPAROLinkFactory.from_cid_iparo(cid, iparo)\r\n        self.assertEqual(ipfs.retrieve_nth_iparo(99, link), link)\r\n\r\n    def test_can_get_nth_iparo_if_iparo_seq_num_is_less_than_input_seq_num(self):\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 55)\r\n        expected_fetched_link = ipfs.retrieve_iparo_by_url_and_number(URL, 44)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        link = IPAROLinkFactory.from_cid_iparo(link.cid, iparo)\r\n        fetched_link = ipfs.retrieve_nth_iparo(44, link)\r\n        self.assertEqual(fetched_link, expected_fetched_link)\r\n\r\n    def test_can_get_multiple_indices_in_iparo(self):\r\n        links = [ipfs.retrieve_iparo_by_url_and_number(URL, i*i) for i in range(10)]\r\n        indices = {i * i for i in range(10)}\r\n        cid = ipns.get_latest_cid(URL)\r\n        iparo = ipfs.retrieve(cid)\r\n        link = IPAROLinkFactory.from_cid_iparo(cid, iparo)\r\n\r\n        observed = list(IPAROLinkFactory.from_indices(link, indices))\r\n\r\n        links.sort(key=lambda link: link.seq_num)\r\n        observed.sort(key=lambda link: link.seq_num)\r\n\r\n        self.assertListEqual(observed, links)\r\n\r\n    # Test cases:\r\n    # 1. Latest IPARO has exact timestamp.\r\n    def test_can_retrieve_closest_iparo_if_the_closest_iparo_has_exact_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=0))\r\n        self.assertEqual(observed_iparo_seq_num, 99)\r\n\r\n    # 2. Latest IPARO is closest.\r\n    def test_can_retrieve_closest_iparo_if_the_closest_iparo_has_closest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=-499))\r\n        self.assertEqual(observed_iparo_seq_num, 99)\r\n\r\n    # 3. Previous IPARO has exact timestamp.\r\n    def test_can_retrieve_previous_iparo_if_the_previous_iparo_has_exact_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(seconds=-1))\r\n        self.assertEqual(observed_iparo_seq_num, 98)\r\n\r\n    # 4. Previous IPARO is closest.\r\n    def test_can_retrieve_previous_iparo_if_the_previous_iparo_has_closest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=-501))\r\n        self.assertEqual(observed_iparo_seq_num, 98)\r\n\r\n    # 5a. Prior nodes are closer.\r\n    def test_can_retrieve_by_timestamp_on_prior_nodes(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(seconds=-44.1))\r\n        self.assertEqual(observed_iparo_seq_num, 55)\r\n\r\n    # 5b. In particular, if first prior node (i.e. node before previous node) is closest, then\r\n    # it should give the first prior node.\r\n    def test_can_retrieve_by_timestamp_on_first_prior_node(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(seconds=-1.9))\r\n        self.assertEqual(observed_iparo_seq_num, 97)\r\n\r\n    # 6. Timestamp comes after latest node.\r\n    def test_can_return_latest_node_if_timestamp_goes_after_latest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=1))\r\n        self.assertEqual(observed_iparo_seq_num, 99)\r\n\r\n    # 7. Timestamp comes before earliest node.\r\n    def test_can_return_earliest_node_if_timestamp_goes_before_earliest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(minutes=-2))\r\n        self.assertEqual(observed_iparo_seq_num, 0)\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/IPFSTest.py b/test/IPFSTest.py
--- a/test/IPFSTest.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/test/IPFSTest.py	(date 1744656337740)
@@ -88,7 +88,7 @@
         iparo2.linked_iparos = {IPAROLinkFactory.from_cid_iparo(cid, iparo1)}
         cid2 = ipfs.store(iparo2)
         ipns.update(URL, cid2)
-        cids = {link.cid for link in ipfs.get_all_links(URL)}
+        cids = {iparo.cid for iparo in ipfs.get_all_iparos(URL)}
         self.assertSetEqual(cids, {cid, cid2})
 
     def test_ipfs_should_retrieve_by_url_and_number(self):
Index: test/IPAROSimulationTest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\r\nfrom unittest.mock import patch, call\r\n\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPAROSimulation import IPAROSimulation\r\nfrom iparo.LinkingStrategy import *\r\nfrom iparo.IPNS import ipns\r\nfrom iparo.IPFS import ipfs\r\nfrom iparo.VersionDensity import *\r\n\r\n\r\nclass IPAROSimulationTest(unittest.TestCase):\r\n\r\n    def setUp(self):\r\n        IPAROSimulation.reset(reset_data=True)\r\n        linking_strategy = TemporallyUniformStrategy(2)\r\n        self.simulation = IPAROSimulation(linking_strategy=linking_strategy,\r\n                                          version_volume=VersionVolume.MEDIUM,\r\n                                          version_density=UniformVersionDensity())\r\n        self.simulation.run(100, verbose=False)\r\n\r\n    def test_simulation_has_ipns_store_results(self):\r\n        self.assertIsInstance(self.simulation.ipfs_store_results, dict)\r\n\r\n    def test_simulation_has_ipfs_store_results(self):\r\n        self.assertIsInstance(self.simulation.ipns_store_results, dict)\r\n\r\n    def test_simulation_has_ipns_retrieve_results(self):\r\n        self.assertIsInstance(self.simulation.ipns_retrieve_results, dict)\r\n\r\n    def test_simulation_has_ipfs_retrieve_results(self):\r\n        self.assertIsInstance(self.simulation.ipns_retrieve_results, dict)\r\n\r\n    def test_simulation_can_reset(self):\r\n        self.simulation.reset()\r\n        self.assertListEqual([ipns.get_count, ipns.update_count,\r\n                              ipfs.store_count, ipfs.retrieve_count], [0] * 4)\r\n\r\n    def test_simulation_can_reset_data(self):\r\n        self.simulation.reset(reset_data=True)\r\n        self.assertListEqual([ipns.get_count, ipns.update_count,\r\n                              ipfs.store_count, ipfs.retrieve_count], [0] * 4)\r\n\r\n    def test_simulation_can_reset_data_with_no_trace_of_input(self):\r\n        self.simulation.reset(reset_data=True)\r\n        self.assertRaises(IPARONotFoundException, lambda: ipns.get_latest_cid(URL))\r\n        self.assertEqual(len(ipfs.get_all_links(URL)), 0)\r\n\r\n    def test_simulation_can_be_exported_as_graph(self):\r\n        graph = self.simulation.as_graph()\r\n        self.assertEqual(graph.number_of_nodes(), VersionVolume.MEDIUM)\r\n\r\n    def test_simulation_is_verbose_by_default(self):\r\n        self.simulation.reset()\r\n\r\n        # Use mock calls to detect print statements.\r\n        with patch(\"builtins.print\") as mock:\r\n            self.simulation.run(100)\r\n            self.assertIn(call(\"Store\"), mock.mock_calls)\r\n            self.assertIn(call(\"Retrieve\"), mock.mock_calls)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/IPAROSimulationTest.py b/test/IPAROSimulationTest.py
--- a/test/IPAROSimulationTest.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/test/IPAROSimulationTest.py	(date 1744656337702)
@@ -44,7 +44,7 @@
     def test_simulation_can_reset_data_with_no_trace_of_input(self):
         self.simulation.reset(reset_data=True)
         self.assertRaises(IPARONotFoundException, lambda: ipns.get_latest_cid(URL))
-        self.assertEqual(len(ipfs.get_all_links(URL)), 0)
+        self.assertEqual(len(ipfs.get_all_iparos()), 0)
 
     def test_simulation_can_be_exported_as_graph(self):
         graph = self.simulation.as_graph()
Index: src/app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nfrom flask import Flask, request, jsonify\r\nfrom iparo.IPARO import IPARO\r\nfrom io import BytesIO\r\nfrom warcio.archiveiterator import ArchiveIterator\r\nfrom warcio.recordloader import ArchiveLoadFailed\r\nimport os\r\nimport pickle\r\nimport hashlib\r\n\r\napp = Flask(__name__)\r\n\r\nIPFS_API_URL = \"http://127.0.0.1:5001/api/v0\"\r\n\r\n\r\ndef create_iparo(filename=None):\r\n    \"\"\"Processes WARC file, creates IPARO objects, and pushes them to IPFS and IPNS.\"\"\"\r\n    current_dir = os.path.dirname(os.path.abspath(__file__))\r\n    warc_path = os.path.join(current_dir, '..', 'samples', 'warcs', '1memento_noContentType.warc')\r\n    \r\n    with open(warc_path, 'rb') as stream:\r\n        for record in ArchiveIterator(stream):\r\n            if record.rec_type == 'response':\r\n                url = record.rec_headers.get_header('WARC-Target-URI')\r\n                timestamp = record.rec_headers.get_header('WARC-Date')\r\n                content = record.content_stream().read()\r\n                \r\n                iparo_object = IPARO(\r\n                    url=url,\r\n                    timestamp=timestamp,\r\n                    seq_num=0,\r\n                    linked_iparos=set(),\r\n                    content=content,\r\n                    nonce=0\r\n                )\r\n                return iparo_object\r\n            \r\n            \r\ndef generate_key_for_url(url):\r\n    url_hash = hashlib.sha256(url.encode()).hexdigest()\r\n    key_name = f\"urlkey-{url_hash[:10]}\"\r\n\r\n    # Check if key already exists\r\n    existing_keys = requests.post(\"http://127.0.0.1:5001/api/v0/key/list\").json()\r\n    if key_name not in [k[\"Name\"] for k in existing_keys[\"Keys\"]]:\r\n        res = requests.post(\"http://127.0.0.1:5001/api/v0/key/gen\", params={\r\n            \"arg\": key_name,\r\n            \"type\": \"rsa\",\r\n            \"size\": \"2048\"\r\n        })\r\n        print(f\"Generated new key: {key_name}\")\r\n    else:\r\n        print(f\"Using existing key: {key_name}\")\r\n\r\n    return key_name\r\n\r\ndef get_ipns_name_for_key(key_name):\r\n    \"\"\"Returns the IPNS name (PeerID) for a given key.\"\"\"\r\n    response = requests.post(\"http://127.0.0.1:5001/api/v0/key/list\").json()\r\n    for key in response[\"Keys\"]:\r\n        if key[\"Name\"] == key_name:\r\n            return key[\"Id\"]\r\n    raise Exception(f\"Key '{key_name}' not found.\")\r\n\r\ndef add_iparo_to_ipfs(iparo_obj):\r\n    pickled_data = pickle.dumps(iparo_obj)\r\n    response = requests.post(\r\n        f\"{IPFS_API_URL}/add\",\r\n        files={\"file\": (\"iparo.pkl\", pickled_data)}\r\n    )\r\n    print(\"Succesfully add to ipfs\")\r\n    print(f\"IPFS Hash: {response.json()['Hash']}\")\r\n    return response.json()[\"Hash\"]\r\n\r\ndef update_ipns(ipfs_hash, key_name):\r\n    \"\"\"Pins an IPFS hash to IPNS using a specific key.\"\"\"\r\n    response = requests.post(\r\n        f\"{IPFS_API_URL}/name/publish\",\r\n        params={\r\n            \"arg\": f\"/ipfs/{ipfs_hash}\",\r\n            \"key\": key_name\r\n        }\r\n    )\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Failed to publish to IPNS: {response.text}\")\r\n    \r\n    ipns_name = response.json().get(\"Name\", \"Unknown IPNS Name\")\r\n    print(f\" Published to IPNS with key '{key_name}': /ipns/{ipns_name}\")\r\n    return ipns_name\r\n    \r\ndef resolve_ipns_to_cid(key_name):\r\n    \"\"\"Resolve IPNS key to the current IPFS hash (CID).\"\"\"\r\n    response = requests.post(f\"{IPFS_API_URL}/name/resolve\", params={\"arg\": f\"/ipns/{key_name}\"})\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Failed to resolve IPNS: {response.text}\")\r\n    \r\n    path = response.json()[\"Path\"]\r\n    cid = path.split(\"/\")[-1]\r\n    print(f\"Resolved IPNS key '{key_name}' to CID: {cid}\")\r\n    return cid\r\n\r\ndef fetch_iparo_from_ipns(cid):\r\n    \"\"\"Fetch and deserialize an IPARO object from IPFS by CID.\"\"\"\r\n    response = requests.post(f\"{IPFS_API_URL}/cat?arg={cid}\")\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Failed to fetch from IPFS: {response.status_code}\")\r\n    iparo = pickle.loads(response.content)\r\n    return iparo\r\n\r\nnew_iparo = create_iparo()\r\nkey = generate_key_for_url(new_iparo.url)\r\nipns_id = get_ipns_name_for_key(key)\r\ncid = add_iparo_to_ipfs(new_iparo)\r\nipns_name = update_ipns(cid, key)\r\nresolved_cid = resolve_ipns_to_cid(ipns_id)\r\niparo_from_ipns = fetch_iparo_from_ipns(resolved_cid)\r\nprint(iparo_from_ipns)\r\nprint(iparo_from_ipns.__dict__)\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True, use_reloader=False)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app.py b/src/app.py
--- a/src/app.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/app.py	(date 1744656337747)
@@ -41,9 +41,9 @@
     key_name = f"urlkey-{url_hash[:10]}"
 
     # Check if key already exists
-    existing_keys = requests.post("http://127.0.0.1:5001/api/v0/key/list").json()
+    existing_keys = requests.post(f"{IPFS_API_URL}/key/list").json()
     if key_name not in [k["Name"] for k in existing_keys["Keys"]]:
-        res = requests.post("http://127.0.0.1:5001/api/v0/key/gen", params={
+        res = requests.post(f"{IPFS_API_URL}/key/gen", params={
             "arg": key_name,
             "type": "rsa",
             "size": "2048"
@@ -56,7 +56,7 @@
 
 def get_ipns_name_for_key(key_name):
     """Returns the IPNS name (PeerID) for a given key."""
-    response = requests.post("http://127.0.0.1:5001/api/v0/key/list").json()
+    response = requests.post(f"{IPFS_API_URL}/key/list").json()
     for key in response["Keys"]:
         if key["Name"] == key_name:
             return key["Id"]
@@ -99,6 +99,7 @@
     print(f"Resolved IPNS key '{key_name}' to CID: {cid}")
     return cid
 
+
 def fetch_iparo_from_ipns(cid):
     """Fetch and deserialize an IPARO object from IPFS by CID."""
     response = requests.post(f"{IPFS_API_URL}/cat?arg={cid}")
@@ -107,6 +108,7 @@
     iparo = pickle.loads(response.content)
     return iparo
 
+
 new_iparo = create_iparo()
 key = generate_key_for_url(new_iparo.url)
 ipns_id = get_ipns_name_for_key(key)
Index: src/iparo/IPFS.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import hashlib\r\nimport pickle\r\nfrom enum import Enum\r\n\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPARO import IPARO\r\nfrom iparo.IPARODateFormat import IPARODateFormat\r\nfrom iparo.IPAROLink import IPAROLink\r\nfrom iparo.IPNS import ipns\r\n\r\n\r\nclass Mode(Enum):\r\n    LATEST_BEFORE = 0,\r\n    CLOSEST = 1,\r\n    EARLIEST_AFTER = 2\r\n\r\n\r\nclass IPFS:\r\n    \"\"\"\r\n    The InterPlanetary File System is responsible for hashing, storing,\r\n    retrieving, and linking IPARO objects.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        self.data: dict[str, bytes] = {}\r\n        self.retrieve_count = 0\r\n        self.store_count = 0\r\n\r\n    def store(self, iparo: IPARO) -> str:\r\n        \"\"\"\r\n        Stores a node with its CID.\r\n\r\n        Args:\r\n            iparo (IPARO): The IPARO object to store.\r\n\r\n        Returns:\r\n            The CID of the newly stored IPARO.\r\n        \"\"\"\r\n        iparo_bytes = pickle.dumps(iparo)\r\n        sha256_hash = hashlib.sha256(iparo_bytes).hexdigest()\r\n        cid = 'Qm' + sha256_hash[:34]\r\n        self.store_count += 1\r\n        self.data[cid] = iparo_bytes\r\n        return cid\r\n\r\n    def reset_data(self):\r\n        self.data: dict[str, IPARO] = {}\r\n\r\n    def retrieve(self, cid) -> IPARO:\r\n        \"\"\"\r\n        Retrieves the IPARO object corresponding to a given CID, if it exists;\r\n        otherwise, it throws an IPARONotFoundException.\r\n        \"\"\"\r\n        self.retrieve_count += 1\r\n        if cid not in self.data:\r\n            raise IPARONotFoundException(cid)\r\n        iparo_bytes = self.data[cid]\r\n        return pickle.loads(iparo_bytes)\r\n\r\n    def retrieve_by_url_and_timestamp(self, url: str, target_timestamp: str, mode: Mode = Mode.LATEST_BEFORE) -> \\\r\n            IPAROLink:\r\n        link, _ = self.retrieve_closest_iparo(self.get_latest_link(url), set(), target_timestamp, mode)\r\n        return link\r\n\r\n    def retrieve_nth_iparo(self, number: int, link: IPAROLink) -> IPAROLink:\r\n        \"\"\"\r\n        A helper method that enables the retrieval of IPARO using a sequence number\r\n        to save IPARO operations by adding the ability to repeatedly apply the\r\n        greedy search method.\r\n        \"\"\"\r\n        if link.seq_num < number:\r\n            raise IPARONotFoundException(number)\r\n        elif link.seq_num == number:\r\n            return link\r\n\r\n        # It is assumed that there is a link to the previous node.\r\n        iparo = self.retrieve(link.cid)\r\n        candidate_links = [link for link in iparo.linked_iparos if link.seq_num >= number]\r\n        if not candidate_links:\r\n            raise IPARONotFoundException(number)\r\n        next_link = min(candidate_links, key=lambda link: link.seq_num)\r\n\r\n        return self.retrieve_nth_iparo(number, next_link)\r\n\r\n    def retrieve_closest_iparo(self, curr_link: IPAROLink, known_links: set[IPAROLink], timestamp: str,\r\n                               mode: Mode = Mode.CLOSEST)\\\r\n            -> tuple[IPAROLink, set[IPAROLink]]:\r\n        \"\"\"\r\n        A helper method that enables the retrieval of IPARO using a sequence number\r\n        to save IPARO operations by adding the ability to repeatedly apply the\r\n        greedy search method from an IPARO link. Unlike the other method, it only applies\r\n        the closest IPARO.\r\n        \"\"\"\r\n\r\n        curr_ts = curr_link.timestamp\r\n\r\n        try:\r\n            # If current link has the exact timestamp or the current link is the first link:\r\n            if curr_ts == timestamp or curr_link.seq_num == 0:\r\n                return curr_link, known_links\r\n            prev_link = self.retrieve_nth_iparo(curr_link.seq_num - 1, curr_link)\r\n            prev_ts = prev_link.timestamp\r\n            # Calculate time fraction.\r\n            time_frac = IPARODateFormat.diff(timestamp, prev_ts) / IPARODateFormat.diff(curr_ts, prev_ts)\r\n            if time_frac >= 0:\r\n                if mode == Mode.CLOSEST:\r\n                    chosen_link = prev_link if time_frac <= 0.5 else curr_link\r\n                elif mode == Mode.EARLIEST_AFTER:\r\n                    chosen_link = curr_link if time_frac > 0 else prev_link\r\n                else:\r\n                    chosen_link = prev_link if time_frac < 1 else curr_link\r\n                return chosen_link, known_links\r\n\r\n            # Go over known links...\r\n            iparo = self.retrieve(prev_link.cid)\r\n\r\n            candidate_links = iparo.linked_iparos\r\n            candidate_links.add(prev_link)\r\n\r\n            known_links.update(candidate_links)\r\n\r\n            # Find minimum time greater than the timestamp.\r\n            next_link = min({link for link in known_links if link.timestamp > timestamp},\r\n                            key=lambda link: link.timestamp)\r\n            return self.retrieve_closest_iparo(next_link, known_links, timestamp, mode)\r\n        except IPARONotFoundException as e:\r\n            raise e\r\n\r\n    def retrieve_iparo_by_url_and_number(self, url: str, number: int) -> IPAROLink:\r\n        \"\"\"\r\n        Retrieves the IPARO CID corresponding to a given sequence number and a URL.\r\n        Usually only used for tests.\r\n        \"\"\"\r\n        cid = ipns.get_latest_cid(url)\r\n\r\n        # To avoid a circular dependency on IPAROLinkFactory\r\n        iparo = self.retrieve(cid)\r\n        link = IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)\r\n        result = self.retrieve_nth_iparo(number, link)\r\n        return result\r\n\r\n    def get_counts(self) -> dict:\r\n        \"\"\"\r\n        Returns the number of store, and retrieve operations performed.\r\n\r\n        Returns:\r\n            dict: Dictionary with counts of store, and retrieve operations.\r\n        \"\"\"\r\n        counts = {\"store\": self.store_count, \"retrieve\": self.retrieve_count}\r\n        return counts\r\n\r\n    def reset_counts(self):\r\n        \"\"\"\r\n        Resets the operation counters.\r\n        \"\"\"\r\n        self.store_count = 0\r\n        self.retrieve_count = 0\r\n\r\n    def get_all_links(self, url: str) -> list[IPAROLink]:\r\n        \"\"\"\r\n        Retrieves the list of all links in the IPFS, corresponding to the given URL.\r\n        The links are sorted from latest to earliest. This will also include all the CIDs.\r\n        \"\"\"\r\n        links = []\r\n        try:\r\n            link = self.get_latest_link(url)\r\n            while True:\r\n                links.append(link)\r\n                link = self.retrieve_nth_iparo(link.seq_num - 1, link)\r\n        finally:\r\n            return links\r\n\r\n    def get_latest_link(self, url: str) -> IPAROLink:\r\n        cid = ipns.get_latest_cid(url)\r\n        iparo = self.retrieve(cid)\r\n        return IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)\r\n\r\n    def get_all_iparos(self, url: str) -> list[IPARO]:\r\n        \"\"\"\r\n        Retrieves the list of all IPAROs in the IPFS, corresponding to the given URL.\r\n        The nodes are sorted from latest to earliest. This will also include all the CIDs.\r\n        \"\"\"\r\n        iparos = []\r\n        try:\r\n            cid = ipns.get_latest_cid(url)\r\n            while True:\r\n                iparo = self.retrieve(cid)\r\n                iparos.append(iparo)\r\n\r\n                links = [link for link in iparo.linked_iparos if link.seq_num == iparo.seq_num - 1]\r\n                if len(links) == 0:\r\n                    raise IPARONotFoundException()\r\n                cid = links[0].cid\r\n        finally:\r\n            return iparos\r\n\r\n\r\nipfs = IPFS()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPFS.py b/src/iparo/IPFS.py
--- a/src/iparo/IPFS.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPFS.py	(date 1744656337723)
@@ -156,20 +156,6 @@
         self.store_count = 0
         self.retrieve_count = 0
 
-    def get_all_links(self, url: str) -> list[IPAROLink]:
-        """
-        Retrieves the list of all links in the IPFS, corresponding to the given URL.
-        The links are sorted from latest to earliest. This will also include all the CIDs.
-        """
-        links = []
-        try:
-            link = self.get_latest_link(url)
-            while True:
-                links.append(link)
-                link = self.retrieve_nth_iparo(link.seq_num - 1, link)
-        finally:
-            return links
-
     def get_latest_link(self, url: str) -> IPAROLink:
         cid = ipns.get_latest_cid(url)
         iparo = self.retrieve(cid)
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"9288c70e-2960-4e90-a337-b37f2cbbb71f\" name=\"Changes\" comment=\"\">\r\n      <change afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/src/iparo/IPARODateFormat.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/Exceptions.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/Exceptions.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPARODateConverter.py\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPAROFactory.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPAROFactory.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPAROSimulation.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPAROSimulation.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPFS.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPFS.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPNS.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPNS.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/LinkingStrategy.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/LinkingStrategy.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/VersionDensity.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/VersionDensity.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/__init__.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/__init__.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROSimulationTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROSimulationTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROStrategyTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROStrategyTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROTestConstants.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROTestConstants.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROTestHelpers.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROTestHelpers.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPFSTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPFSTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPNSTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPNSTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/VersionDensityTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/VersionDensityTest.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 4\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2uAmi4QeLGK4nnUyUY2ww85A6zf\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest.executor\": \"Run\",\r\n    \"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.executor\": \"Run\",\r\n    \"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node.executor\": \"Run\",\r\n    \"Python tests.Python tests for VersionDensityTest.VersionDensityTestCase.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPAROStrategyTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPAROTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPFSTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPNSTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in test.executor\": \"Run\",\r\n    \"Python tests.Unittests for IPFSTest.IPAROLinkFactoryTest.test_can_raise_exception_if_timestamp_goes_after_latest_timestamp.executor\": \"Debug\",\r\n    \"Python tests.Unittests for IPFSTest.IPAROLinkFactoryTest.test_can_retrieve_by_timestamp_on_first_prior_node.executor\": \"Run\",\r\n    \"Python.IPAROSimulation.executor\": \"Run\",\r\n    \"Python.MasterTest.executor\": \"Run\",\r\n    \"Python.app.executor\": \"Run\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"ptl46\",\r\n    \"last_opened_file_path\": \"C:/Users/patri/OneDrive/Documents/GitHub/iparo/backend/src/iparo/IPFS.py\",\r\n    \"settings.editor.selected.configurable\": \"editor.preferences.fonts.default\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\" selected=\"Python.MasterTest\">\r\n    <configuration name=\"MasterTest\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/test/MasterTest.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"PythonConfigurationType\" factoryName=\"Python\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"Tox\" factoryName=\"Tox\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Docutils task\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Sphinx task\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for IPAROSimulationTest.IPAROSimulationTest\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;IPAROSimulationTest.IPAROSimulationTest&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for IPAROStrategyTest.IPAROStrategyTest\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;IPAROStrategyTest.IPAROStrategyTest&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for VersionDensityTest.VersionDensityTestCase\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;VersionDensityTest.VersionDensityTestCase&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.MasterTest\" />\r\n        <item itemvalue=\"Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest\" />\r\n        <item itemvalue=\"Python tests.Python tests for VersionDensityTest.VersionDensityTestCase\" />\r\n        <item itemvalue=\"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest\" />\r\n        <item itemvalue=\"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-50da183f06c8-d3b881c8e49f-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-233.13135.95\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"9288c70e-2960-4e90-a337-b37f2cbbb71f\" name=\"Changes\" comment=\"\" />\r\n      <created>1742230161614</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1742230161614</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/test/IPAROTestHelpers.py</url>\r\n          <line>103</line>\r\n          <option name=\"timeStamp\" value=\"5\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/test/IPAROTestHelpers.py</url>\r\n          <line>89</line>\r\n          <option name=\"timeStamp\" value=\"12\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/.idea/workspace.xml	(date 1744656338222)
@@ -5,26 +5,13 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="9288c70e-2960-4e90-a337-b37f2cbbb71f" name="Changes" comment="">
-      <change afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/iparo/IPARODateFormat.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/Exceptions.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/Exceptions.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/IPARODateConverter.py" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/IPAROFactory.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPAROFactory.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/app.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/app.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/IPAROSimulation.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPAROSimulation.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/IPFS.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPFS.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/IPNS.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPNS.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/LinkingStrategy.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/LinkingStrategy.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/VersionDensity.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/VersionDensity.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/__init__.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/__init__.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/test/IPAROSimulationTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROSimulationTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPAROStrategyTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROStrategyTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPAROTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPAROTestConstants.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROTestConstants.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPAROTestHelpers.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROTestHelpers.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/test/IPFSTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPFSTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPNSTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPNSTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/VersionDensityTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/VersionDensityTest.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -39,6 +26,11 @@
     </option>
   </component>
   <component name="Git.Settings">
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$/.." value="ptl46" />
+      </map>
+    </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
   </component>
   <component name="ProjectColorInfo">{
@@ -66,12 +58,12 @@
     "Python.MasterTest.executor": "Run",
     "Python.app.executor": "Run",
     "RunOnceActivity.OpenProjectViewOnStart": "true",
-    "git-widget-placeholder": "ptl46",
+    "git-widget-placeholder": "qb42",
     "last_opened_file_path": "C:/Users/patri/OneDrive/Documents/GitHub/iparo/backend/src/iparo/IPFS.py",
     "settings.editor.selected.configurable": "editor.preferences.fonts.default"
   }
 }]]></component>
-  <component name="RunManager" selected="Python.MasterTest">
+  <component name="RunManager" selected="Python.app">
     <configuration name="MasterTest" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="backend" />
       <option name="ENV_FILES" value="" />
@@ -94,7 +86,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration default="true" type="PythonConfigurationType" factoryName="Python">
+    <configuration name="app" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="backend" />
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -103,63 +95,17 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/src" />
+      <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/src/app.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
       <option name="MODULE_MODE" value="false" />
       <option name="REDIRECT_INPUT" value="false" />
       <option name="INPUT_FILE" value="" />
-      <method v="2" />
-    </configuration>
-    <configuration default="true" type="Tox" factoryName="Tox">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <method v="2" />
-    </configuration>
-    <configuration default="true" type="docs" factoryName="Docutils task">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="docutils_input_file" value="" />
-      <option name="docutils_output_file" value="" />
-      <option name="docutils_params" value="" />
-      <option name="docutils_task" value="" />
-      <option name="docutils_open_in_browser" value="false" />
-      <method v="2" />
-    </configuration>
-    <configuration default="true" type="docs" factoryName="Sphinx task">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="docutils_input_file" value="" />
-      <option name="docutils_output_file" value="" />
-      <option name="docutils_params" value="" />
-      <option name="docutils_task" value="" />
-      <option name="docutils_open_in_browser" value="false" />
       <method v="2" />
     </configuration>
     <configuration name="Python tests for IPAROSimulationTest.IPAROSimulationTest" type="tests" factoryName="Autodetect" temporary="true" nameIsGenerated="true">
@@ -192,21 +138,6 @@
       <option name="_new_targetType" value="&quot;PYTHON&quot;" />
       <method v="2" />
     </configuration>
-    <configuration name="Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node" type="tests" factoryName="Autodetect" temporary="true" nameIsGenerated="true">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/test" />
-      <option name="IS_MODULE_SDK" value="true" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="_new_additionalArguments" value="&quot;&quot;" />
-      <option name="_new_target" value="&quot;IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node&quot;" />
-      <option name="_new_targetType" value="&quot;PYTHON&quot;" />
-      <method v="2" />
-    </configuration>
     <configuration name="Python tests for VersionDensityTest.VersionDensityTestCase" type="tests" factoryName="Autodetect" temporary="true" nameIsGenerated="true">
       <module name="backend" />
       <option name="ENV_FILES" value="" />
@@ -224,11 +155,11 @@
     </configuration>
     <recent_temporary>
       <list>
-        <item itemvalue="Python.MasterTest" />
-        <item itemvalue="Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest" />
+        <item itemvalue="Python.app" />
         <item itemvalue="Python tests.Python tests for VersionDensityTest.VersionDensityTestCase" />
         <item itemvalue="Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest" />
-        <item itemvalue="Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node" />
+        <item itemvalue="Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest" />
+        <item itemvalue="Python.MasterTest" />
       </list>
     </recent_temporary>
   </component>
