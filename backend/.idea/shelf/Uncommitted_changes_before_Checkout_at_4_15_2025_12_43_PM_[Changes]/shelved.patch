Index: src/iparo/IPNS.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from datetime import datetime\r\n\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPARODateFormat import IPARODateFormat\r\n\r\n\r\nclass IPNS:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize the IPNS object with an empty hashmap for storing CIDs\r\n        and counters for tracking operations.\r\n        \"\"\"\r\n        self.__store: dict[str, str] = {}\r\n        self.__versions: dict[tuple[str, str], str] = {}\r\n        self.update_count = 0\r\n        self.get_count = 0\r\n\r\n    # Add parameter datetime - str\r\n    def update(self, url: str, cid: str, timestamp: str = 'latest'):\r\n        \"\"\"\r\n        Updates the latest CID for a given URL with a given timestamp.\r\n\r\n        Args:\r\n            url (str): The URL of the website.\r\n            cid (str): The CID of the latest capture.\r\n            timestamp (str): The string containing the timestamp (YYYY-mm-dd hh:mm:ss).\r\n            Default is latest.\r\n        \"\"\"\r\n        self.update_count += 1\r\n        curr_timestamp = datetime.strftime(datetime.now(), IPARODateFormat.DATE_FORMAT)\\\r\n            if timestamp == 'latest' else timestamp\r\n\r\n        # /archive/latest/{url} -> value of URL, map it to the CID [default]\r\n        self.__store[url] = cid\r\n\r\n        # /archive/{datetime}/{url} -> convert datetime, map it to the CID\r\n        self.__versions[(url, curr_timestamp)] = cid\r\n\r\n    # Optional parameter: datetime ([un]serialized), default value is latest.\r\n    def get_latest_cid(self, url: str) -> str:\r\n        \"\"\"\r\n        Retrieves the latest CID for a given URL if it exists, else None.\r\n\r\n        Args:\r\n            url (str): The URL of the website.\r\n\r\n        Returns:\r\n            str: The CID of the latest capture for the given URL if it exists, else None.\r\n\r\n        Exceptions:\r\n            EmptyError: If the URL is not found.\r\n        \"\"\"\r\n        self.get_count += 1\r\n        if url not in self.__store:\r\n            raise IPARONotFoundException(url)\r\n        return self.__store[url]\r\n\r\n    def get_cid(self, url: str, timestamp: str) -> str:\r\n        \"\"\"\r\n        Retrieves the CID for a given timestamp.\r\n\r\n        Args:\r\n            url (str): The URL of the website.\r\n            timestamp (str): The 14-character-long timestamp for the\r\n\r\n        Returns:\r\n            str: The CID of the latest capture for the given URL if it exists, else None.\r\n        \"\"\"\r\n        self.get_count += 1\r\n        return self.__versions[(url, timestamp)]\r\n\r\n    def get_counts(self):\r\n        \"\"\"\r\n        Returns the number of update and get operations performed.\r\n\r\n        Returns:\r\n            dict: Dictionary with the counts of update and get operations.\r\n        \"\"\"\r\n        return {\"get\": self.get_count, \"update\": self.update_count}\r\n\r\n    def reset_data(self):\r\n        \"\"\"\r\n        Resets the data.\r\n        \"\"\"\r\n        self.__store: dict[str, str] = {}\r\n\r\n    def reset_counts(self):\r\n        \"\"\"\r\n        Resets the operating counts. Used for the evaluation phase.\r\n        \"\"\"\r\n        self.update_count = 0\r\n        self.get_count = 0\r\n\r\n    def get_store(self):\r\n        return self.__store\r\n\r\n\r\nipns = IPNS()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPNS.py b/src/iparo/IPNS.py
--- a/src/iparo/IPNS.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPNS.py	(date 1744735162790)
@@ -1,99 +1,72 @@
+import hashlib
 from datetime import datetime
 
+import requests
+
 from iparo.IPAROException import IPARONotFoundException
 from iparo.IPARODateFormat import IPARODateFormat
 
+IPFS_API_URL = "http://127.0.0.1:5001/api/v0"
+
 
 class IPNS:
 
     def __init__(self):
-        """
-        Initialize the IPNS object with an empty hashmap for storing CIDs
-        and counters for tracking operations.
-        """
-        self.__store: dict[str, str] = {}
-        self.__versions: dict[tuple[str, str], str] = {}
-        self.update_count = 0
-        self.get_count = 0
-
-    # Add parameter datetime - str
-    def update(self, url: str, cid: str, timestamp: str = 'latest'):
-        """
-        Updates the latest CID for a given URL with a given timestamp.
-
-        Args:
-            url (str): The URL of the website.
-            cid (str): The CID of the latest capture.
-            timestamp (str): The string containing the timestamp (YYYY-mm-dd hh:mm:ss).
-            Default is latest.
-        """
-        self.update_count += 1
-        curr_timestamp = datetime.strftime(datetime.now(), IPARODateFormat.DATE_FORMAT)\
-            if timestamp == 'latest' else timestamp
-
-        # /archive/latest/{url} -> value of URL, map it to the CID [default]
-        self.__store[url] = cid
-
-        # /archive/{datetime}/{url} -> convert datetime, map it to the CID
-        self.__versions[(url, curr_timestamp)] = cid
-
-    # Optional parameter: datetime ([un]serialized), default value is latest.
-    def get_latest_cid(self, url: str) -> str:
-        """
-        Retrieves the latest CID for a given URL if it exists, else None.
-
-        Args:
-            url (str): The URL of the website.
+        pass
 
-        Returns:
-            str: The CID of the latest capture for the given URL if it exists, else None.
+    @classmethod
+    def generate_key_for_url(cls, url):
+        url_hash = hashlib.sha256(url.encode()).hexdigest()
+        key_name = f"urlkey-{url_hash[:10]}"
 
-        Exceptions:
-            EmptyError: If the URL is not found.
-        """
-        self.get_count += 1
-        if url not in self.__store:
-            raise IPARONotFoundException(url)
-        return self.__store[url]
+        # Check if key already exists
+        existing_keys = requests.post(f"{IPFS_API_URL}/key/list").json()
+        if key_name not in [k["Name"] for k in existing_keys["Keys"]]:
+            res = requests.post(f"{IPFS_API_URL}/key/gen", params={
+                "arg": key_name,
+                "type": "rsa",
+                "size": "2048"
+            })
+            print(f"Generated new key: {key_name}")
+        else:
+            print(f"Using existing key: {key_name}")
 
-    def get_cid(self, url: str, timestamp: str) -> str:
-        """
-        Retrieves the CID for a given timestamp.
+        return key_name
 
-        Args:
-            url (str): The URL of the website.
-            timestamp (str): The 14-character-long timestamp for the
+    @classmethod
+    def get_name_for_key(cls, key_name):
+        """Returns the IPNS name (PeerID) for a given key."""
+        response = requests.post(f"{IPFS_API_URL}/key/list").json()
+        for key in response["Keys"]:
+            if key["Name"] == key_name:
+                return key["Id"]
+        raise Exception(f"Key '{key_name}' not found.")
 
-        Returns:
-            str: The CID of the latest capture for the given URL if it exists, else None.
-        """
-        self.get_count += 1
-        return self.__versions[(url, timestamp)]
+    @classmethod
+    def update(cls, ipfs_hash, key_name):
+        """Pins an IPFS hash to IPNS using a specific key."""
+        response = requests.post(
+            f"{IPFS_API_URL}/name/publish",
+            params={
+                "arg": f"/ipfs/{ipfs_hash}",
+                "key": key_name
+            }
+        )
+        if response.status_code != 200:
+            raise Exception(f"Failed to publish to IPNS: {response.text}")
 
-    def get_counts(self):
-        """
-        Returns the number of update and get operations performed.
+        ipns_name = response.json().get("Name", "Unknown IPNS Name")
+        print(f" Published to IPNS with key '{key_name}': /ipns/{ipns_name}")
+        return ipns_name
 
-        Returns:
-            dict: Dictionary with the counts of update and get operations.
-        """
-        return {"get": self.get_count, "update": self.update_count}
+    @classmethod
+    def resolve_ipns_to_cid(cls, key_name):
+        """Resolve IPNS key to the current IPFS hash (CID)."""
+        response = requests.post(f"{IPFS_API_URL}/name/resolve", params={"arg": f"/ipns/{key_name}"})
+        if response.status_code != 200:
+            raise Exception(f"Failed to resolve IPNS: {response.text}")
 
-    def reset_data(self):
-        """
-        Resets the data.
-        """
-        self.__store: dict[str, str] = {}
-
-    def reset_counts(self):
-        """
-        Resets the operating counts. Used for the evaluation phase.
-        """
-        self.update_count = 0
-        self.get_count = 0
-
-    def get_store(self):
-        return self.__store
-
-
-ipns = IPNS()
+        path = response.json()["Path"]
+        cid = path.split("/")[-1]
+        print(f"Resolved IPNS key '{key_name}' to CID: {cid}")
+        return cid
Index: src/iparo/IPAROSimulation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.LinkingStrategy import *\r\n\r\nimport networkx as nx\r\n\r\nfrom iparo.VersionDensity import *\r\nfrom iparo.IPFS import ipfs\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\nclass IPAROSimulation:\r\n    \"\"\"\r\n    The class for the testing environment.\r\n    \"\"\"\r\n\r\n    def __init__(self, linking_strategy: LinkingStrategy, version_density: VersionDensity,\r\n                 version_volume: VersionVolume):\r\n        self.linking_strategy = linking_strategy\r\n        self.version_density = version_density\r\n        self.version_volume = version_volume\r\n\r\n        # Debug variables for testing.\r\n        self.ipfs_store_results: dict[str, int] = dict()\r\n        self.ipns_store_results: dict[str, int] = dict()\r\n        self.ipfs_retrieve_results: dict[str, int] = dict()\r\n        self.ipns_retrieve_results: dict[str, int] = dict()\r\n\r\n    def run(self, k: int, verbose=True):\r\n        \"\"\"\r\n        Sets up the testing environment for an IPARO simulation, and then\r\n        performs k random.\r\n        \"\"\"\r\n        nodes = self.version_density.get_iparos(self.version_volume)\r\n        # Link the IPAROs in the IPFS\r\n        for i, node in enumerate(nodes):\r\n            node.seq_num = i\r\n            try:\r\n                node.linked_iparos = self.linking_strategy.get_candidate_nodes(URL)\r\n            except IPARONotFoundException:\r\n                node.linked_iparos = set()\r\n            cid = ipfs.store(node)\r\n            ipns.update(URL, cid)\r\n\r\n        self.ipfs_store_results = ipfs.get_counts()\r\n        self.ipns_store_results = ipns.get_counts()\r\n        if verbose:\r\n            IPAROSimulation.print_counts(\"Store\")\r\n        IPAROSimulation.reset()\r\n\r\n        # Get node number from latest CID\r\n        latest_cid = ipns.get_latest_cid(URL)\r\n        latest_node = ipfs.retrieve(latest_cid)\r\n        for i in range(k):\r\n            selected_index = random.randint(0, latest_node.seq_num - 1)\r\n\r\n            # The intent is to find separate numbers, where the numbers are not known until at runtime.\r\n            ipfs.retrieve_iparo_by_url_and_number(URL, selected_index)\r\n        if verbose:\r\n            IPAROSimulation.print_counts(\"Retrieve\")\r\n\r\n        self.ipfs_retrieve_results = ipfs.get_counts()\r\n        self.ipns_retrieve_results = ipns.get_counts()\r\n\r\n    @classmethod\r\n    def print_counts(cls, header: str):\r\n        \"\"\"\r\n        A tool that can be useful in debugging.\r\n        \"\"\"\r\n        print(header)\r\n        print(\"IPFS Counts:\")\r\n        print(ipfs.get_counts())\r\n        print(\"IPNS Counts:\")\r\n        print(ipns.get_counts())\r\n\r\n    def as_graph(self):\r\n        \"\"\"\r\n        Creates a DiGraph object out of the current nodes in the IPFS.\r\n        \"\"\"\r\n        # Do comprehensive\r\n        nx_graph = nx.DiGraph()\r\n        for iparo in ipfs.get_all_iparos(URL):\r\n            curr_num = iparo.seq_num\r\n            nx_graph.add_node(curr_num)\r\n            for link in iparo.linked_iparos:\r\n                nx_graph.add_edge(curr_num, link.seq_num)\r\n\r\n        return nx_graph\r\n\r\n    @classmethod\r\n    def reset(cls, reset_data=False):\r\n        \"\"\"Resets the counts (and optionally, the data) from the IPNS and IPFS.\"\"\"\r\n        if reset_data:\r\n            ipfs.reset_data()\r\n            ipns.reset_data()\r\n        ipfs.reset_counts()\r\n        ipns.reset_counts()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    linking_strategy = TemporallyUniformStrategy(2)\r\n    simulation = IPAROSimulation(linking_strategy=linking_strategy,\r\n                                 version_volume=VersionVolume.MEDIUM,\r\n                                 version_density=UniformVersionDensity())\r\n    simulation.run(100, verbose=False)\r\n    nx.draw_networkx(simulation.as_graph(), arrows=True)\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPAROSimulation.py b/src/iparo/IPAROSimulation.py
--- a/src/iparo/IPAROSimulation.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPAROSimulation.py	(date 1744735293698)
@@ -4,7 +4,7 @@
 import networkx as nx
 
 from iparo.VersionDensity import *
-from iparo.IPFS import ipfs
+from iparo.mock.IPFS import ipfs
 import matplotlib.pyplot as plt
 
 
@@ -28,7 +28,7 @@
     def run(self, k: int, verbose=True):
         """
         Sets up the testing environment for an IPARO simulation, and then
-        performs k random.
+        performs k random-uniform retrievals.
         """
         nodes = self.version_density.get_iparos(self.version_volume)
         # Link the IPAROs in the IPFS
Index: test/IPFSTest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\r\n\r\nfrom IPAROTestConstants import *\r\nfrom IPAROTestHelpers import add_nodes, test_strategy, test_closest_iparo\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPAROLinkFactory import IPAROLinkFactory\r\nfrom iparo.IPFS import ipfs, Mode\r\nfrom iparo.IPNS import ipns\r\nfrom iparo.LinkingStrategy import SingleStrategy\r\n\r\ntimestamp = datetime.now()\r\n\r\n\r\nclass IPFSTest(unittest.TestCase):\r\n\r\n    def tearDown(self):\r\n        ipns.reset_data()\r\n        ipns.reset_counts()\r\n        ipfs.reset_data()\r\n        ipfs.reset_counts()\r\n\r\n    def test_ipfs_counters_should_be_zero_initially(self):\r\n        self.assertEqual(ipfs.retrieve_count, 0)\r\n        self.assertEqual(ipfs.store_count, 0)\r\n\r\n    def test_ipfs_should_initially_have_no_iparos(self):\r\n        self.assertDictEqual(ipfs.data, {})\r\n\r\n    def test_ipfs_should_store_one_iparo(self):\r\n        cid = ipfs.store(iparo1)\r\n        self.assertIn(cid, ipfs.data)\r\n\r\n    def test_ipfs_should_retrieve_iparos(self):\r\n        cid = ipfs.store(iparo1)\r\n        iparo = ipfs.retrieve(cid)\r\n        self.assertEqual(iparo, iparo1)\r\n\r\n    def test_ipfs_should_count_retrievals(self):\r\n        cid = ipfs.store(iparo1)\r\n        ipfs.retrieve(cid)\r\n        self.assertEqual(ipfs.retrieve_count, 1)\r\n\r\n    def test_ipfs_should_retrieve_iparos_twice(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        node1 = ipfs.retrieve(cid)\r\n        node2 = ipfs.retrieve(cid2)\r\n        self.assertEqual(node1, iparo1)\r\n        self.assertEqual(node2, iparo2)\r\n\r\n    # Note: The converse of the proposition implied by the test is not necessarily true.\r\n    # That is, different IPAROs can have the same CIDs, but the same IPARO cannot have\r\n    # two different CIDs. We can see this in more detail when we get there.\r\n    def test_different_cids_should_yield_different_iparos(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        node1 = ipfs.retrieve(cid)\r\n        node2 = ipfs.retrieve(cid2)\r\n        self.assertNotEqual(node1, node2)\r\n\r\n    def test_ipfs_should_update_retrieval_counts_twice(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        ipfs.retrieve(cid)\r\n        ipfs.retrieve(cid2)\r\n        self.assertEqual(ipfs.retrieve_count, 2)\r\n\r\n    def test_ipfs_should_store_two_iparos(self):\r\n        cid = ipfs.store(iparo1)\r\n        cid2 = ipfs.store(iparo2)\r\n        self.assertIn(cid, ipfs.data)\r\n        self.assertIn(cid2, ipfs.data)\r\n\r\n    def test_ipfs_versions_should_initially_be_empty(self):\r\n        cids = ipfs.get_all_iparos(URL)\r\n        self.assertEqual(len(cids), 0)\r\n\r\n    def test_ipfs_versions_should_update_on_one_insert(self):\r\n        cid = ipfs.store(iparo1)\r\n        ipns.update(URL, cid)\r\n        cids = ipfs.get_all_iparos(URL)\r\n        self.assertEqual(len(cids), 1)\r\n\r\n    def test_ipfs_versions_should_update_on_two_inserts(self):\r\n        cid = ipfs.store(iparo1)\r\n        ipns.update(URL, cid)\r\n\r\n        iparo2.linked_iparos = {IPAROLinkFactory.from_cid_iparo(cid, iparo1)}\r\n        cid2 = ipfs.store(iparo2)\r\n        ipns.update(URL, cid2)\r\n        cids = {link.cid for link in ipfs.get_all_links(URL)}\r\n        self.assertSetEqual(cids, {cid, cid2})\r\n\r\n    def test_ipfs_should_retrieve_by_url_and_number(self):\r\n        iparos = add_nodes(3)\r\n\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 0)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[0])\r\n\r\n    def test_ipfs_should_retrieve_last_node(self):\r\n        iparos = add_nodes(3)\r\n\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 2)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[2])\r\n\r\n    def test_ipfs_should_retrieve_middle_node(self):\r\n        iparos = add_nodes(10)\r\n\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 5)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_retrieve_latest_time_before_target_timestamp_by_default(self):\r\n        iparos = add_nodes(100)\r\n\r\n        timestamp = datetime.strftime(time1 + timedelta(seconds=55), IPARODateFormat.DATE_FORMAT)\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, timestamp)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_raise_error_if_no_iparo_is_inserted_into_ipfs(self):\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_by_url_and_timestamp(URL, time1, Mode.CLOSEST))\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_by_url_and_timestamp(URL, time1,\r\n                                                                                             Mode.EARLIEST_AFTER))\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_by_url_and_timestamp(URL, time1))\r\n\r\n    def test_ipfs_should_retrieve_earliest_time_after_target_timestamp(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=51), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.EARLIEST_AFTER)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[6])\r\n\r\n    def test_ipfs_should_retrieve_target_timestamp_if_there_exists_a_cid_with_the_target_timestamp(self):\r\n        iparos = add_nodes(100)\r\n\r\n        time = datetime.strftime(time1 + timedelta(seconds=50), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link1 = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.EARLIEST_AFTER)\r\n        link2 = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        link3 = ipfs.retrieve_by_url_and_timestamp(URL, time)\r\n\r\n        links = {link1, link2, link3}\r\n        iparo = ipfs.retrieve(link1.cid)\r\n\r\n        self.assertEqual(iparo, iparos[5])\r\n        self.assertSetEqual(links, {link1})\r\n\r\n    def test_ipfs_should_retrieve_earlier_time_if_two_closest_timestamps_are_equally_distant(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=55), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_retrieve_earlier_time_if_closest_timestamp_is_earlier(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=54), IPARODateFormat.DATE_FORMAT)\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n    def test_ipfs_should_retrieve_earlier_time_if_closest_timestamp_is_later(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=56), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[6])\r\n\r\n    def test_ipfs_should_retrieve_earliest_time_after_timestamp(self):\r\n        iparos = add_nodes(100)\r\n        time = datetime.strftime(time1 + timedelta(seconds=54), IPARODateFormat.DATE_FORMAT)\r\n\r\n        link = ipfs.retrieve_by_url_and_timestamp(URL, time, Mode.CLOSEST)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        self.assertEqual(iparo, iparos[5])\r\n\r\n\r\nclass IPAROLinkFactoryTest(unittest.TestCase):\r\n\r\n    def setUp(self):\r\n        # Will produce 100 nodes, each uniformly distributed with interval = 1 second.\r\n        test_strategy(SingleStrategy())\r\n\r\n    def test_can_throw_when_iparo_seq_num_is_less_than_input_seq_num(self):\r\n        cid = ipns.get_latest_cid(URL)\r\n        iparo = ipfs.retrieve(cid)\r\n        self.assertRaises(IPARONotFoundException, lambda: ipfs.retrieve_nth_iparo(100, iparo))\r\n\r\n    def test_can_get_latest_iparo_if_iparo_seq_num_is_equal_to_input_seq_num(self):\r\n        cid = ipns.get_latest_cid(URL)\r\n        iparo = ipfs.retrieve(cid)\r\n        link = IPAROLinkFactory.from_cid_iparo(cid, iparo)\r\n        self.assertEqual(ipfs.retrieve_nth_iparo(99, link), link)\r\n\r\n    def test_can_get_nth_iparo_if_iparo_seq_num_is_less_than_input_seq_num(self):\r\n        link = ipfs.retrieve_iparo_by_url_and_number(URL, 55)\r\n        expected_fetched_link = ipfs.retrieve_iparo_by_url_and_number(URL, 44)\r\n        iparo = ipfs.retrieve(link.cid)\r\n        link = IPAROLinkFactory.from_cid_iparo(link.cid, iparo)\r\n        fetched_link = ipfs.retrieve_nth_iparo(44, link)\r\n        self.assertEqual(fetched_link, expected_fetched_link)\r\n\r\n    def test_can_get_multiple_indices_in_iparo(self):\r\n        links = [ipfs.retrieve_iparo_by_url_and_number(URL, i*i) for i in range(10)]\r\n        indices = {i * i for i in range(10)}\r\n        cid = ipns.get_latest_cid(URL)\r\n        iparo = ipfs.retrieve(cid)\r\n        link = IPAROLinkFactory.from_cid_iparo(cid, iparo)\r\n\r\n        observed = list(IPAROLinkFactory.from_indices(link, indices))\r\n\r\n        links.sort(key=lambda link: link.seq_num)\r\n        observed.sort(key=lambda link: link.seq_num)\r\n\r\n        self.assertListEqual(observed, links)\r\n\r\n    # Test cases:\r\n    # 1. Latest IPARO has exact timestamp.\r\n    def test_can_retrieve_closest_iparo_if_the_closest_iparo_has_exact_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=0))\r\n        self.assertEqual(observed_iparo_seq_num, 99)\r\n\r\n    # 2. Latest IPARO is closest.\r\n    def test_can_retrieve_closest_iparo_if_the_closest_iparo_has_closest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=-499))\r\n        self.assertEqual(observed_iparo_seq_num, 99)\r\n\r\n    # 3. Previous IPARO has exact timestamp.\r\n    def test_can_retrieve_previous_iparo_if_the_previous_iparo_has_exact_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(seconds=-1))\r\n        self.assertEqual(observed_iparo_seq_num, 98)\r\n\r\n    # 4. Previous IPARO is closest.\r\n    def test_can_retrieve_previous_iparo_if_the_previous_iparo_has_closest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=-501))\r\n        self.assertEqual(observed_iparo_seq_num, 98)\r\n\r\n    # 5a. Prior nodes are closer.\r\n    def test_can_retrieve_by_timestamp_on_prior_nodes(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(seconds=-44.1))\r\n        self.assertEqual(observed_iparo_seq_num, 55)\r\n\r\n    # 5b. In particular, if first prior node (i.e. node before previous node) is closest, then\r\n    # it should give the first prior node.\r\n    def test_can_retrieve_by_timestamp_on_first_prior_node(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(seconds=-1.9))\r\n        self.assertEqual(observed_iparo_seq_num, 97)\r\n\r\n    # 6. Timestamp comes after latest node.\r\n    def test_can_return_latest_node_if_timestamp_goes_after_latest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(milliseconds=1))\r\n        self.assertEqual(observed_iparo_seq_num, 99)\r\n\r\n    # 7. Timestamp comes before earliest node.\r\n    def test_can_return_earliest_node_if_timestamp_goes_before_earliest_timestamp(self):\r\n        observed_iparo_seq_num = test_closest_iparo(timedelta(minutes=-2))\r\n        self.assertEqual(observed_iparo_seq_num, 0)\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/IPFSTest.py b/test/IPFSTest.py
--- a/test/IPFSTest.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/test/IPFSTest.py	(date 1744735285068)
@@ -4,8 +4,8 @@
 from IPAROTestHelpers import add_nodes, test_strategy, test_closest_iparo
 from iparo.IPAROException import IPARONotFoundException
 from iparo.IPAROLinkFactory import IPAROLinkFactory
-from iparo.IPFS import ipfs, Mode
-from iparo.IPNS import ipns
+from iparo.mock.IPFS import ipfs, Mode
+from iparo.mock.IPNS import ipns
 from iparo.LinkingStrategy import SingleStrategy
 
 timestamp = datetime.now()
@@ -88,7 +88,7 @@
         iparo2.linked_iparos = {IPAROLinkFactory.from_cid_iparo(cid, iparo1)}
         cid2 = ipfs.store(iparo2)
         ipns.update(URL, cid2)
-        cids = {link.cid for link in ipfs.get_all_links(URL)}
+        cids = {iparo.cid for iparo in ipfs.get_all_iparos(URL)}
         self.assertSetEqual(cids, {cid, cid2})
 
     def test_ipfs_should_retrieve_by_url_and_number(self):
Index: src/iparo/IPFS.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import hashlib\r\nimport pickle\r\nfrom enum import Enum\r\n\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPARO import IPARO\r\nfrom iparo.IPARODateFormat import IPARODateFormat\r\nfrom iparo.IPAROLink import IPAROLink\r\nfrom iparo.IPNS import ipns\r\n\r\n\r\nclass Mode(Enum):\r\n    LATEST_BEFORE = 0,\r\n    CLOSEST = 1,\r\n    EARLIEST_AFTER = 2\r\n\r\n\r\nclass IPFS:\r\n    \"\"\"\r\n    The InterPlanetary File System is responsible for hashing, storing,\r\n    retrieving, and linking IPARO objects.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        self.data: dict[str, bytes] = {}\r\n        self.retrieve_count = 0\r\n        self.store_count = 0\r\n\r\n    def store(self, iparo: IPARO) -> str:\r\n        \"\"\"\r\n        Stores a node with its CID.\r\n\r\n        Args:\r\n            iparo (IPARO): The IPARO object to store.\r\n\r\n        Returns:\r\n            The CID of the newly stored IPARO.\r\n        \"\"\"\r\n        iparo_bytes = pickle.dumps(iparo)\r\n        sha256_hash = hashlib.sha256(iparo_bytes).hexdigest()\r\n        cid = 'Qm' + sha256_hash[:34]\r\n        self.store_count += 1\r\n        self.data[cid] = iparo_bytes\r\n        return cid\r\n\r\n    def reset_data(self):\r\n        self.data: dict[str, IPARO] = {}\r\n\r\n    def retrieve(self, cid) -> IPARO:\r\n        \"\"\"\r\n        Retrieves the IPARO object corresponding to a given CID, if it exists;\r\n        otherwise, it throws an IPARONotFoundException.\r\n        \"\"\"\r\n        self.retrieve_count += 1\r\n        if cid not in self.data:\r\n            raise IPARONotFoundException(cid)\r\n        iparo_bytes = self.data[cid]\r\n        return pickle.loads(iparo_bytes)\r\n\r\n    def retrieve_by_url_and_timestamp(self, url: str, target_timestamp: str, mode: Mode = Mode.LATEST_BEFORE) -> \\\r\n            IPAROLink:\r\n        link, _ = self.retrieve_closest_iparo(self.get_latest_link(url), set(), target_timestamp, mode)\r\n        return link\r\n\r\n    def retrieve_nth_iparo(self, number: int, link: IPAROLink) -> IPAROLink:\r\n        \"\"\"\r\n        A helper method that enables the retrieval of IPARO using a sequence number\r\n        to save IPARO operations by adding the ability to repeatedly apply the\r\n        greedy search method.\r\n        \"\"\"\r\n        if link.seq_num < number:\r\n            raise IPARONotFoundException(number)\r\n        elif link.seq_num == number:\r\n            return link\r\n\r\n        # It is assumed that there is a link to the previous node.\r\n        iparo = self.retrieve(link.cid)\r\n        candidate_links = [link for link in iparo.linked_iparos if link.seq_num >= number]\r\n        if not candidate_links:\r\n            raise IPARONotFoundException(number)\r\n        next_link = min(candidate_links, key=lambda link: link.seq_num)\r\n\r\n        return self.retrieve_nth_iparo(number, next_link)\r\n\r\n    def retrieve_closest_iparo(self, curr_link: IPAROLink, known_links: set[IPAROLink], timestamp: str,\r\n                               mode: Mode = Mode.CLOSEST)\\\r\n            -> tuple[IPAROLink, set[IPAROLink]]:\r\n        \"\"\"\r\n        A helper method that enables the retrieval of IPARO using a sequence number\r\n        to save IPARO operations by adding the ability to repeatedly apply the\r\n        greedy search method from an IPARO link. Unlike the other method, it only applies\r\n        the closest IPARO.\r\n        \"\"\"\r\n\r\n        curr_ts = curr_link.timestamp\r\n\r\n        try:\r\n            # If current link has the exact timestamp or the current link is the first link:\r\n            if curr_ts == timestamp or curr_link.seq_num == 0:\r\n                return curr_link, known_links\r\n            prev_link = self.retrieve_nth_iparo(curr_link.seq_num - 1, curr_link)\r\n            prev_ts = prev_link.timestamp\r\n            # Calculate time fraction.\r\n            time_frac = IPARODateFormat.diff(timestamp, prev_ts) / IPARODateFormat.diff(curr_ts, prev_ts)\r\n            if time_frac >= 0:\r\n                if mode == Mode.CLOSEST:\r\n                    chosen_link = prev_link if time_frac <= 0.5 else curr_link\r\n                elif mode == Mode.EARLIEST_AFTER:\r\n                    chosen_link = curr_link if time_frac > 0 else prev_link\r\n                else:\r\n                    chosen_link = prev_link if time_frac < 1 else curr_link\r\n                return chosen_link, known_links\r\n\r\n            # Go over known links...\r\n            iparo = self.retrieve(prev_link.cid)\r\n\r\n            candidate_links = iparo.linked_iparos\r\n            candidate_links.add(prev_link)\r\n\r\n            known_links.update(candidate_links)\r\n\r\n            # Find minimum time greater than the timestamp.\r\n            next_link = min({link for link in known_links if link.timestamp > timestamp},\r\n                            key=lambda link: link.timestamp)\r\n            return self.retrieve_closest_iparo(next_link, known_links, timestamp, mode)\r\n        except IPARONotFoundException as e:\r\n            raise e\r\n\r\n    def retrieve_iparo_by_url_and_number(self, url: str, number: int) -> IPAROLink:\r\n        \"\"\"\r\n        Retrieves the IPARO CID corresponding to a given sequence number and a URL.\r\n        Usually only used for tests.\r\n        \"\"\"\r\n        cid = ipns.get_latest_cid(url)\r\n\r\n        # To avoid a circular dependency on IPAROLinkFactory\r\n        iparo = self.retrieve(cid)\r\n        link = IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)\r\n        result = self.retrieve_nth_iparo(number, link)\r\n        return result\r\n\r\n    def get_counts(self) -> dict:\r\n        \"\"\"\r\n        Returns the number of store, and retrieve operations performed.\r\n\r\n        Returns:\r\n            dict: Dictionary with counts of store, and retrieve operations.\r\n        \"\"\"\r\n        counts = {\"store\": self.store_count, \"retrieve\": self.retrieve_count}\r\n        return counts\r\n\r\n    def reset_counts(self):\r\n        \"\"\"\r\n        Resets the operation counters.\r\n        \"\"\"\r\n        self.store_count = 0\r\n        self.retrieve_count = 0\r\n\r\n    def get_all_links(self, url: str) -> list[IPAROLink]:\r\n        \"\"\"\r\n        Retrieves the list of all links in the IPFS, corresponding to the given URL.\r\n        The links are sorted from latest to earliest. This will also include all the CIDs.\r\n        \"\"\"\r\n        links = []\r\n        try:\r\n            link = self.get_latest_link(url)\r\n            while True:\r\n                links.append(link)\r\n                link = self.retrieve_nth_iparo(link.seq_num - 1, link)\r\n        finally:\r\n            return links\r\n\r\n    def get_latest_link(self, url: str) -> IPAROLink:\r\n        cid = ipns.get_latest_cid(url)\r\n        iparo = self.retrieve(cid)\r\n        return IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)\r\n\r\n    def get_all_iparos(self, url: str) -> list[IPARO]:\r\n        \"\"\"\r\n        Retrieves the list of all IPAROs in the IPFS, corresponding to the given URL.\r\n        The nodes are sorted from latest to earliest. This will also include all the CIDs.\r\n        \"\"\"\r\n        iparos = []\r\n        try:\r\n            cid = ipns.get_latest_cid(url)\r\n            while True:\r\n                iparo = self.retrieve(cid)\r\n                iparos.append(iparo)\r\n\r\n                links = [link for link in iparo.linked_iparos if link.seq_num == iparo.seq_num - 1]\r\n                if len(links) == 0:\r\n                    raise IPARONotFoundException()\r\n                cid = links[0].cid\r\n        finally:\r\n            return iparos\r\n\r\n\r\nipfs = IPFS()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPFS.py b/src/iparo/IPFS.py
--- a/src/iparo/IPFS.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPFS.py	(date 1744735162814)
@@ -1,18 +1,9 @@
-import hashlib
 import pickle
-from enum import Enum
 
-from iparo.IPAROException import IPARONotFoundException
-from iparo.IPARO import IPARO
-from iparo.IPARODateFormat import IPARODateFormat
-from iparo.IPAROLink import IPAROLink
-from iparo.IPNS import ipns
+import requests
 
-
-class Mode(Enum):
-    LATEST_BEFORE = 0,
-    CLOSEST = 1,
-    EARLIEST_AFTER = 2
+# TODO: put in env file.
+IPFS_API_URL = "http://127.0.0.1:5001/api/v0"
 
 
 class IPFS:
@@ -21,178 +12,17 @@
     retrieving, and linking IPARO objects.
     """
 
-    def __init__(self):
-        self.data: dict[str, bytes] = {}
-        self.retrieve_count = 0
-        self.store_count = 0
-
-    def store(self, iparo: IPARO) -> str:
-        """
-        Stores a node with its CID.
-
-        Args:
-            iparo (IPARO): The IPARO object to store.
-
-        Returns:
-            The CID of the newly stored IPARO.
-        """
-        iparo_bytes = pickle.dumps(iparo)
-        sha256_hash = hashlib.sha256(iparo_bytes).hexdigest()
-        cid = 'Qm' + sha256_hash[:34]
-        self.store_count += 1
-        self.data[cid] = iparo_bytes
-        return cid
-
-    def reset_data(self):
-        self.data: dict[str, IPARO] = {}
-
-    def retrieve(self, cid) -> IPARO:
-        """
-        Retrieves the IPARO object corresponding to a given CID, if it exists;
-        otherwise, it throws an IPARONotFoundException.
-        """
-        self.retrieve_count += 1
-        if cid not in self.data:
-            raise IPARONotFoundException(cid)
-        iparo_bytes = self.data[cid]
-        return pickle.loads(iparo_bytes)
-
-    def retrieve_by_url_and_timestamp(self, url: str, target_timestamp: str, mode: Mode = Mode.LATEST_BEFORE) -> \
-            IPAROLink:
-        link, _ = self.retrieve_closest_iparo(self.get_latest_link(url), set(), target_timestamp, mode)
-        return link
-
-    def retrieve_nth_iparo(self, number: int, link: IPAROLink) -> IPAROLink:
-        """
-        A helper method that enables the retrieval of IPARO using a sequence number
-        to save IPARO operations by adding the ability to repeatedly apply the
-        greedy search method.
-        """
-        if link.seq_num < number:
-            raise IPARONotFoundException(number)
-        elif link.seq_num == number:
-            return link
-
-        # It is assumed that there is a link to the previous node.
-        iparo = self.retrieve(link.cid)
-        candidate_links = [link for link in iparo.linked_iparos if link.seq_num >= number]
-        if not candidate_links:
-            raise IPARONotFoundException(number)
-        next_link = min(candidate_links, key=lambda link: link.seq_num)
-
-        return self.retrieve_nth_iparo(number, next_link)
-
-    def retrieve_closest_iparo(self, curr_link: IPAROLink, known_links: set[IPAROLink], timestamp: str,
-                               mode: Mode = Mode.CLOSEST)\
-            -> tuple[IPAROLink, set[IPAROLink]]:
-        """
-        A helper method that enables the retrieval of IPARO using a sequence number
-        to save IPARO operations by adding the ability to repeatedly apply the
-        greedy search method from an IPARO link. Unlike the other method, it only applies
-        the closest IPARO.
-        """
-
-        curr_ts = curr_link.timestamp
-
-        try:
-            # If current link has the exact timestamp or the current link is the first link:
-            if curr_ts == timestamp or curr_link.seq_num == 0:
-                return curr_link, known_links
-            prev_link = self.retrieve_nth_iparo(curr_link.seq_num - 1, curr_link)
-            prev_ts = prev_link.timestamp
-            # Calculate time fraction.
-            time_frac = IPARODateFormat.diff(timestamp, prev_ts) / IPARODateFormat.diff(curr_ts, prev_ts)
-            if time_frac >= 0:
-                if mode == Mode.CLOSEST:
-                    chosen_link = prev_link if time_frac <= 0.5 else curr_link
-                elif mode == Mode.EARLIEST_AFTER:
-                    chosen_link = curr_link if time_frac > 0 else prev_link
-                else:
-                    chosen_link = prev_link if time_frac < 1 else curr_link
-                return chosen_link, known_links
-
-            # Go over known links...
-            iparo = self.retrieve(prev_link.cid)
-
-            candidate_links = iparo.linked_iparos
-            candidate_links.add(prev_link)
-
-            known_links.update(candidate_links)
-
-            # Find minimum time greater than the timestamp.
-            next_link = min({link for link in known_links if link.timestamp > timestamp},
-                            key=lambda link: link.timestamp)
-            return self.retrieve_closest_iparo(next_link, known_links, timestamp, mode)
-        except IPARONotFoundException as e:
-            raise e
-
-    def retrieve_iparo_by_url_and_number(self, url: str, number: int) -> IPAROLink:
-        """
-        Retrieves the IPARO CID corresponding to a given sequence number and a URL.
-        Usually only used for tests.
-        """
-        cid = ipns.get_latest_cid(url)
-
-        # To avoid a circular dependency on IPAROLinkFactory
-        iparo = self.retrieve(cid)
-        link = IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)
-        result = self.retrieve_nth_iparo(number, link)
-        return result
-
-    def get_counts(self) -> dict:
-        """
-        Returns the number of store, and retrieve operations performed.
-
-        Returns:
-            dict: Dictionary with counts of store, and retrieve operations.
-        """
-        counts = {"store": self.store_count, "retrieve": self.retrieve_count}
-        return counts
-
-    def reset_counts(self):
-        """
-        Resets the operation counters.
-        """
-        self.store_count = 0
-        self.retrieve_count = 0
-
-    def get_all_links(self, url: str) -> list[IPAROLink]:
-        """
-        Retrieves the list of all links in the IPFS, corresponding to the given URL.
-        The links are sorted from latest to earliest. This will also include all the CIDs.
-        """
-        links = []
-        try:
-            link = self.get_latest_link(url)
-            while True:
-                links.append(link)
-                link = self.retrieve_nth_iparo(link.seq_num - 1, link)
-        finally:
-            return links
+    @classmethod
+    def retrieve_latest_node(cls, cid):
+        """Fetch and deserialize an IPARO object from IPFS by CID."""
+        response = requests.post(f"{IPFS_API_URL}/cat?arg={cid}")
+        if response.status_code != 200:
+            raise Exception(f"Failed to fetch from IPFS: {response.status_code}")
+        iparo = pickle.loads(response.content)
+        return iparo
 
-    def get_latest_link(self, url: str) -> IPAROLink:
-        cid = ipns.get_latest_cid(url)
-        iparo = self.retrieve(cid)
-        return IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)
 
-    def get_all_iparos(self, url: str) -> list[IPARO]:
-        """
-        Retrieves the list of all IPAROs in the IPFS, corresponding to the given URL.
-        The nodes are sorted from latest to earliest. This will also include all the CIDs.
-        """
-        iparos = []
-        try:
-            cid = ipns.get_latest_cid(url)
-            while True:
-                iparo = self.retrieve(cid)
-                iparos.append(iparo)
 
-                links = [link for link in iparo.linked_iparos if link.seq_num == iparo.seq_num - 1]
-                if len(links) == 0:
-                    raise IPARONotFoundException()
-                cid = links[0].cid
-        finally:
-            return iparos
-
-
-ipfs = IPFS()
+    @classmethod
+    def retrieve(cls, cid):
+        pass
\ No newline at end of file
Index: src/iparo/IPAROLinkFactory.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from datetime import datetime\r\nfrom typing import Optional\r\n\r\nfrom iparo.IPARO import IPARO\r\nfrom iparo.IPAROLink import IPAROLink\r\nfrom iparo.IPFS import ipfs\r\nfrom iparo.IPNS import ipns\r\n\r\n\r\nclass IPAROLinkFactory:\r\n    \"\"\"\r\n    A collection of helper methods dealing with creating IPAROLinks\r\n    \"\"\"\r\n    def __init__(self):\r\n        pass\r\n\r\n    @classmethod\r\n    def from_cid(cls, cid: str) -> Optional[IPAROLink]:\r\n        \"\"\"\r\n        A helper method that takes in a CID and outputs an IPAROLink (or None if there is no such IPARO)\r\n        :param cid: The CID of the IPARO.\r\n        :return: The link to the IPARO if the CID is present.\r\n        \"\"\"\r\n        iparo = ipfs.retrieve(cid)\r\n        if iparo is None:\r\n            return None\r\n        return IPAROLink(seq_num=iparo.seq_num, timestamp=iparo.timestamp, cid=cid)\r\n\r\n    @classmethod\r\n    def from_cid_iparo(cls, cid: str, iparo: IPARO) -> IPAROLink:\r\n        \"\"\"\r\n        A helper method that takes in a CID and the corresponding IPARO object, and\r\n        outputs an IPAROLink. The assumption underlying the operation is that the\r\n        IPARO's CID maps directly to the IPARO object. This will save an IPFS\r\n        operation each time the method is called, and it does not require a check\r\n        for ``None``.\r\n\r\n        :param iparo: The IPARO object itself.\r\n        :param cid: The CID of the IPARO.\r\n        :return: The link to the IPARO\r\n        \"\"\"\r\n        return IPAROLink(seq_num=iparo.seq_num, timestamp=iparo.timestamp, cid=cid)\r\n\r\n    @classmethod\r\n    def from_indices(cls, link: IPAROLink, indices: set[int]) -> set[IPAROLink]:\r\n        \"\"\"\r\n        A helper method that allows the IPFS to retrieve the selected versions of a URL,\r\n        using the latest node.\r\n        \"\"\"\r\n        sorted_indices = sorted(indices, reverse=True)\r\n        curr_link = link\r\n        links = set()\r\n        for index in sorted_indices:\r\n            curr_link = ipfs.retrieve_nth_iparo(index, curr_link)\r\n            links.add(curr_link)\r\n\r\n        return links\r\n\r\n    @classmethod\r\n    def from_timestamps(cls, link: IPAROLink, known_links: set[IPAROLink], timestamps: set[str]) -> tuple[set[IPAROLink], set[IPAROLink]]:\r\n        \"\"\"\r\n        Constructs a list of IPARO links from a set of timestamps.\r\n        \"\"\"\r\n        # Question: Would timestamps be set[str] or should it be left as set[datetime]?\r\n        sorted_timestamps = sorted(timestamps, reverse=True)\r\n        links = set()\r\n        for ts in sorted_timestamps:\r\n            # Question: Should I just add one known link for each time I iterate through?\r\n            # Or should I just add all the IPARO's links in the list?\r\n            known_links.add(link)\r\n            link, known_links = ipfs.retrieve_closest_iparo(link, known_links, ts)\r\n            links.add(link)\r\n\r\n        return links, known_links\r\n\r\n    @classmethod\r\n    def get_links_to_first_and_latest_nodes(self, url) -> tuple[IPAROLink, IPAROLink, IPARO]:\r\n        \"\"\"\r\n        A helper method that adds the first and latest links.\r\n        \"\"\"\r\n        latest_cid = ipns.get_latest_cid(url)\r\n        latest_iparo = ipfs.retrieve(latest_cid)\r\n        latest_link = IPAROLink(seq_num=latest_iparo.seq_num, timestamp=latest_iparo.timestamp, cid=latest_cid)\r\n        first_link = ipfs.retrieve_nth_iparo(0, latest_link)\r\n        return first_link, latest_link, latest_iparo\r\n\r\n    @classmethod\r\n    def get_link_to_latest_node(self, url) -> tuple[IPAROLink, IPARO]:\r\n        \"\"\"\r\n        A helper method that adds the first and latest links.\r\n        \"\"\"\r\n        latest_cid = ipns.get_latest_cid(url)\r\n        latest_iparo = ipfs.retrieve(latest_cid)\r\n        latest_link = IPAROLink(seq_num=latest_iparo.seq_num, timestamp=latest_iparo.timestamp, cid=latest_cid)\r\n        return latest_link, latest_iparo\r\n\r\n    @classmethod\r\n    def get_latest_node_links(self, url) -> tuple[set[IPAROLink], IPAROLink, IPARO]:\r\n        \"\"\"\r\n        A helper method to get the latest link as well as the set of all IPARO links for the latest node.\r\n        \"\"\"\r\n        latest_cid = ipns.get_latest_cid(url)\r\n        latest_iparo = ipfs.retrieve(latest_cid)\r\n        linked_iparos = latest_iparo.linked_iparos\r\n        latest_iparo_link = IPAROLinkFactory.from_cid_iparo(latest_cid, latest_iparo)\r\n        linked_iparos.add(latest_iparo_link)\r\n\r\n        return linked_iparos, latest_iparo_link, latest_iparo\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPAROLinkFactory.py b/src/iparo/IPAROLinkFactory.py
--- a/src/iparo/IPAROLinkFactory.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPAROLinkFactory.py	(date 1744735162752)
@@ -1,10 +1,9 @@
-from datetime import datetime
 from typing import Optional
 
 from iparo.IPARO import IPARO
 from iparo.IPAROLink import IPAROLink
-from iparo.IPFS import ipfs
-from iparo.IPNS import ipns
+from iparo.mock.IPFS import ipfs
+from iparo.mock.IPNS import ipns
 
 
 class IPAROLinkFactory:
Index: src/iparo/IPARODateFormat.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from datetime import datetime, timedelta\r\n\r\n\r\nclass IPARODateFormat:\r\n    \"\"\"\r\n    The date formatter class converts a string to a datetime and a datetime to a string.\r\n    The format is YYYY-MM-DDThh:mm:ss.ffffffZ, where the ffffff represents the 6 digits\r\n    for the microseconds.\r\n    \"\"\"\r\n    DATE_FORMAT = \"%Y-%m-%dT%H:%M:%S.%fZ\"\r\n    \"\"\"\r\n    The date format string used to perform a conversion, based on the latest WARC version.\r\n    \"\"\"\r\n\r\n    @classmethod\r\n    def diff(cls, timestamp1: str, timestamp2: str):\r\n        \"\"\"\r\n        Calculates the difference between two timestamps. The result is\r\n        equal to `datetime.strptime(timestamp1, IPARODateFormat.DATE_FORMAT) -\r\n        datetime.strptime(timestamp2, IPARODateFormat.DATE_FORMAT)`.\r\n\r\n        Args:\r\n            timestamp1 (str): The first timestamp string.\r\n            timestamp2 (str): The second timestamp string.\r\n\r\n        Returns:\r\n            The difference between ``timestamp1`` and ``timestamp2``\r\n        \"\"\"\r\n        ts1 = datetime.strptime(timestamp1, IPARODateFormat.DATE_FORMAT)\r\n        ts2 = datetime.strptime(timestamp2, IPARODateFormat.DATE_FORMAT)\r\n\r\n        return ts1 - ts2\r\n\r\n    # Question: Should we have add_timedelta, add_timedeltas, or diff methods?\r\n    @classmethod\r\n    def add_timedelta(cls, timestamp: str, delta: timedelta):\r\n        \"\"\"\r\n        Calculates the sum of a timestamp (given in string form) and a given time\r\n        difference. The result is equal to\r\n        ``datetime.strftime(datetime.strptime(timestamp, IPARODateFormat.DATE_FORMAT) + delta)``.\r\n\r\n        Args:\r\n            timestamp (str): The first timestamp string.\r\n            delta (timedelta): The time difference.\r\n\r\n        Returns:\r\n            The sum of timestamp and delta.\r\n        \"\"\"\r\n        return datetime.strftime(datetime.strptime(timestamp, IPARODateFormat.DATE_FORMAT) + delta,\r\n                                 IPARODateFormat.DATE_FORMAT)\r\n\r\n    @classmethod\r\n    def add_timedeltas(cls, timestamp: str, deltas: list[timedelta]):\r\n        \"\"\"\r\n        Calculates the sum of a timestamp (given in string form) and a given time\r\n        difference. The result is equal to\r\n        ``datetime.strftime(datetime.strptime(timestamp, IPARODateFormat.DATE_FORMAT) + delta)``\r\n        The difference is that it will save many calls to `datetime.strptime`.\r\n\r\n        Args:\r\n            timestamp (str): The first timestamp string.\r\n            deltas (list[timedelta]): The time differences.\r\n\r\n        Returns:\r\n            The list of sums of `timestamp` and `deltas`\r\n        \"\"\"\r\n        ts = datetime.strptime(timestamp, IPARODateFormat.DATE_FORMAT)\r\n        return [datetime.strftime(ts + delta, IPARODateFormat.DATE_FORMAT) for delta in deltas]\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPARODateFormat.py b/src/iparo/IPARODateFormat.py
--- a/src/iparo/IPARODateFormat.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPARODateFormat.py	(date 1744735162761)
@@ -1,4 +1,5 @@
 from datetime import datetime, timedelta
+from enum import Enum
 
 
 class IPARODateFormat:
@@ -66,3 +67,9 @@
         """
         ts = datetime.strptime(timestamp, IPARODateFormat.DATE_FORMAT)
         return [datetime.strftime(ts + delta, IPARODateFormat.DATE_FORMAT) for delta in deltas]
+
+
+class Mode(Enum):
+    LATEST_BEFORE = 0,
+    CLOSEST = 1,
+    EARLIEST_AFTER = 2
\ No newline at end of file
Index: test/IPAROSimulationTest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\r\nfrom unittest.mock import patch, call\r\n\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPAROSimulation import IPAROSimulation\r\nfrom iparo.LinkingStrategy import *\r\nfrom iparo.IPNS import ipns\r\nfrom iparo.IPFS import ipfs\r\nfrom iparo.VersionDensity import *\r\n\r\n\r\nclass IPAROSimulationTest(unittest.TestCase):\r\n\r\n    def setUp(self):\r\n        IPAROSimulation.reset(reset_data=True)\r\n        linking_strategy = TemporallyUniformStrategy(2)\r\n        self.simulation = IPAROSimulation(linking_strategy=linking_strategy,\r\n                                          version_volume=VersionVolume.MEDIUM,\r\n                                          version_density=UniformVersionDensity())\r\n        self.simulation.run(100, verbose=False)\r\n\r\n    def test_simulation_has_ipns_store_results(self):\r\n        self.assertIsInstance(self.simulation.ipfs_store_results, dict)\r\n\r\n    def test_simulation_has_ipfs_store_results(self):\r\n        self.assertIsInstance(self.simulation.ipns_store_results, dict)\r\n\r\n    def test_simulation_has_ipns_retrieve_results(self):\r\n        self.assertIsInstance(self.simulation.ipns_retrieve_results, dict)\r\n\r\n    def test_simulation_has_ipfs_retrieve_results(self):\r\n        self.assertIsInstance(self.simulation.ipns_retrieve_results, dict)\r\n\r\n    def test_simulation_can_reset(self):\r\n        self.simulation.reset()\r\n        self.assertListEqual([ipns.get_count, ipns.update_count,\r\n                              ipfs.store_count, ipfs.retrieve_count], [0] * 4)\r\n\r\n    def test_simulation_can_reset_data(self):\r\n        self.simulation.reset(reset_data=True)\r\n        self.assertListEqual([ipns.get_count, ipns.update_count,\r\n                              ipfs.store_count, ipfs.retrieve_count], [0] * 4)\r\n\r\n    def test_simulation_can_reset_data_with_no_trace_of_input(self):\r\n        self.simulation.reset(reset_data=True)\r\n        self.assertRaises(IPARONotFoundException, lambda: ipns.get_latest_cid(URL))\r\n        self.assertEqual(len(ipfs.get_all_links(URL)), 0)\r\n\r\n    def test_simulation_can_be_exported_as_graph(self):\r\n        graph = self.simulation.as_graph()\r\n        self.assertEqual(graph.number_of_nodes(), VersionVolume.MEDIUM)\r\n\r\n    def test_simulation_is_verbose_by_default(self):\r\n        self.simulation.reset()\r\n\r\n        # Use mock calls to detect print statements.\r\n        with patch(\"builtins.print\") as mock:\r\n            self.simulation.run(100)\r\n            self.assertIn(call(\"Store\"), mock.mock_calls)\r\n            self.assertIn(call(\"Retrieve\"), mock.mock_calls)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/IPAROSimulationTest.py b/test/IPAROSimulationTest.py
--- a/test/IPAROSimulationTest.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/test/IPAROSimulationTest.py	(date 1744735162867)
@@ -5,7 +5,7 @@
 from iparo.IPAROSimulation import IPAROSimulation
 from iparo.LinkingStrategy import *
 from iparo.IPNS import ipns
-from iparo.IPFS import ipfs
+from iparo.ipfs.IPFS import ipfs
 from iparo.VersionDensity import *
 
 
@@ -44,7 +44,7 @@
     def test_simulation_can_reset_data_with_no_trace_of_input(self):
         self.simulation.reset(reset_data=True)
         self.assertRaises(IPARONotFoundException, lambda: ipns.get_latest_cid(URL))
-        self.assertEqual(len(ipfs.get_all_links(URL)), 0)
+        self.assertEqual(len(ipfs.get_all_iparos()), 0)
 
     def test_simulation_can_be_exported_as_graph(self):
         graph = self.simulation.as_graph()
Index: src/iparo/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>__all__ = [\"IPAROLink\", \"IPAROException\", \"IPARO\", \"IPAROSimulation\", \"IPARODateFormat\", \"IPAROFactory\",\r\n           \"IPAROLinkFactory\", \"IPFS\", \"IPNS\", \"LinkingStrategy\", \"VersionDensity\"]\r\n\r\n# Import the submodules\r\nfrom . import (IPAROLink, IPARO, IPAROException, IPAROSimulation, IPARODateFormat,\r\n               IPAROFactory, IPAROLinkFactory, IPFS, IPNS, LinkingStrategy, VersionDensity)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/__init__.py b/src/iparo/__init__.py
--- a/src/iparo/__init__.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/__init__.py	(date 1744735329946)
@@ -1,6 +1,6 @@
 __all__ = ["IPAROLink", "IPAROException", "IPARO", "IPAROSimulation", "IPARODateFormat", "IPAROFactory",
-           "IPAROLinkFactory", "IPFS", "IPNS", "LinkingStrategy", "VersionDensity"]
+           "IPAROLinkFactory", "mock", "LinkingStrategy", "VersionDensity"]
 
 # Import the submodules
 from . import (IPAROLink, IPARO, IPAROException, IPAROSimulation, IPARODateFormat,
-               IPAROFactory, IPAROLinkFactory, IPFS, IPNS, LinkingStrategy, VersionDensity)
\ No newline at end of file
+               IPAROFactory, IPAROLinkFactory, mock, LinkingStrategy, VersionDensity)
\ No newline at end of file
Index: src/app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nfrom flask import Flask, request, jsonify\r\nfrom iparo.IPARO import IPARO\r\nfrom io import BytesIO\r\nfrom warcio.archiveiterator import ArchiveIterator\r\nfrom warcio.recordloader import ArchiveLoadFailed\r\nimport os\r\nimport pickle\r\nimport hashlib\r\n\r\napp = Flask(__name__)\r\n\r\nIPFS_API_URL = \"http://127.0.0.1:5001/api/v0\"\r\n\r\n\r\ndef create_iparo(filename=None):\r\n    \"\"\"Processes WARC file, creates IPARO objects, and pushes them to IPFS and IPNS.\"\"\"\r\n    current_dir = os.path.dirname(os.path.abspath(__file__))\r\n    warc_path = os.path.join(current_dir, '..', 'samples', 'warcs', '1memento_noContentType.warc')\r\n    \r\n    with open(warc_path, 'rb') as stream:\r\n        for record in ArchiveIterator(stream):\r\n            if record.rec_type == 'response':\r\n                url = record.rec_headers.get_header('WARC-Target-URI')\r\n                timestamp = record.rec_headers.get_header('WARC-Date')\r\n                content = record.content_stream().read()\r\n                \r\n                iparo_object = IPARO(\r\n                    url=url,\r\n                    timestamp=timestamp,\r\n                    seq_num=0,\r\n                    linked_iparos=set(),\r\n                    content=content,\r\n                    nonce=0\r\n                )\r\n                return iparo_object\r\n            \r\n            \r\ndef generate_key_for_url(url):\r\n    url_hash = hashlib.sha256(url.encode()).hexdigest()\r\n    key_name = f\"urlkey-{url_hash[:10]}\"\r\n\r\n    # Check if key already exists\r\n    existing_keys = requests.post(\"http://127.0.0.1:5001/api/v0/key/list\").json()\r\n    if key_name not in [k[\"Name\"] for k in existing_keys[\"Keys\"]]:\r\n        res = requests.post(\"http://127.0.0.1:5001/api/v0/key/gen\", params={\r\n            \"arg\": key_name,\r\n            \"type\": \"rsa\",\r\n            \"size\": \"2048\"\r\n        })\r\n        print(f\"Generated new key: {key_name}\")\r\n    else:\r\n        print(f\"Using existing key: {key_name}\")\r\n\r\n    return key_name\r\n\r\ndef get_ipns_name_for_key(key_name):\r\n    \"\"\"Returns the IPNS name (PeerID) for a given key.\"\"\"\r\n    response = requests.post(\"http://127.0.0.1:5001/api/v0/key/list\").json()\r\n    for key in response[\"Keys\"]:\r\n        if key[\"Name\"] == key_name:\r\n            return key[\"Id\"]\r\n    raise Exception(f\"Key '{key_name}' not found.\")\r\n\r\ndef add_iparo_to_ipfs(iparo_obj):\r\n    pickled_data = pickle.dumps(iparo_obj)\r\n    response = requests.post(\r\n        f\"{IPFS_API_URL}/add\",\r\n        files={\"file\": (\"iparo.pkl\", pickled_data)}\r\n    )\r\n    print(\"Succesfully add to ipfs\")\r\n    print(f\"IPFS Hash: {response.json()['Hash']}\")\r\n    return response.json()[\"Hash\"]\r\n\r\ndef update_ipns(ipfs_hash, key_name):\r\n    \"\"\"Pins an IPFS hash to IPNS using a specific key.\"\"\"\r\n    response = requests.post(\r\n        f\"{IPFS_API_URL}/name/publish\",\r\n        params={\r\n            \"arg\": f\"/ipfs/{ipfs_hash}\",\r\n            \"key\": key_name\r\n        }\r\n    )\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Failed to publish to IPNS: {response.text}\")\r\n    \r\n    ipns_name = response.json().get(\"Name\", \"Unknown IPNS Name\")\r\n    print(f\" Published to IPNS with key '{key_name}': /ipns/{ipns_name}\")\r\n    return ipns_name\r\n    \r\ndef resolve_ipns_to_cid(key_name):\r\n    \"\"\"Resolve IPNS key to the current IPFS hash (CID).\"\"\"\r\n    response = requests.post(f\"{IPFS_API_URL}/name/resolve\", params={\"arg\": f\"/ipns/{key_name}\"})\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Failed to resolve IPNS: {response.text}\")\r\n    \r\n    path = response.json()[\"Path\"]\r\n    cid = path.split(\"/\")[-1]\r\n    print(f\"Resolved IPNS key '{key_name}' to CID: {cid}\")\r\n    return cid\r\n\r\ndef fetch_iparo_from_ipns(cid):\r\n    \"\"\"Fetch and deserialize an IPARO object from IPFS by CID.\"\"\"\r\n    response = requests.post(f\"{IPFS_API_URL}/cat?arg={cid}\")\r\n    if response.status_code != 200:\r\n        raise Exception(f\"Failed to fetch from IPFS: {response.status_code}\")\r\n    iparo = pickle.loads(response.content)\r\n    return iparo\r\n\r\nnew_iparo = create_iparo()\r\nkey = generate_key_for_url(new_iparo.url)\r\nipns_id = get_ipns_name_for_key(key)\r\ncid = add_iparo_to_ipfs(new_iparo)\r\nipns_name = update_ipns(cid, key)\r\nresolved_cid = resolve_ipns_to_cid(ipns_id)\r\niparo_from_ipns = fetch_iparo_from_ipns(resolved_cid)\r\nprint(iparo_from_ipns)\r\nprint(iparo_from_ipns.__dict__)\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True, use_reloader=False)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app.py b/src/app.py
--- a/src/app.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/app.py	(date 1744735188397)
@@ -41,9 +41,9 @@
     key_name = f"urlkey-{url_hash[:10]}"
 
     # Check if key already exists
-    existing_keys = requests.post("http://127.0.0.1:5001/api/v0/key/list").json()
+    existing_keys = requests.post(f"{IPFS_API_URL}/key/list").json()
     if key_name not in [k["Name"] for k in existing_keys["Keys"]]:
-        res = requests.post("http://127.0.0.1:5001/api/v0/key/gen", params={
+        res = requests.post(f"{IPFS_API_URL}/key/gen", params={
             "arg": key_name,
             "type": "rsa",
             "size": "2048"
@@ -56,7 +56,7 @@
 
 def get_ipns_name_for_key(key_name):
     """Returns the IPNS name (PeerID) for a given key."""
-    response = requests.post("http://127.0.0.1:5001/api/v0/key/list").json()
+    response = requests.post(f"{IPFS_API_URL}/key/list").json()
     for key in response["Keys"]:
         if key["Name"] == key_name:
             return key["Id"]
@@ -99,6 +99,7 @@
     print(f"Resolved IPNS key '{key_name}' to CID: {cid}")
     return cid
 
+
 def fetch_iparo_from_ipns(cid):
     """Fetch and deserialize an IPARO object from IPFS by CID."""
     response = requests.post(f"{IPFS_API_URL}/cat?arg={cid}")
@@ -107,6 +108,7 @@
     iparo = pickle.loads(response.content)
     return iparo
 
+
 new_iparo = create_iparo()
 key = generate_key_for_url(new_iparo.url)
 ipns_id = get_ipns_name_for_key(key)
Index: src/iparo/IPAROFactory.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from datetime import datetime\r\n\r\nfrom iparo.IPAROException import IPARONotFoundException\r\nfrom iparo.IPARO import IPARO\r\nfrom iparo.IPARODateFormat import IPARODateFormat\r\nfrom iparo.IPFS import ipfs\r\nfrom iparo.IPNS import ipns\r\n\r\n\r\nclass IPAROFactory:\r\n    @classmethod\r\n    def create_node(cls, url: str, content: bytes) -> IPARO:\r\n        timestamp = datetime.strftime(datetime.now(), IPARODateFormat.DATE_FORMAT)\r\n        try:\r\n            latest_node = ipfs.retrieve(ipns.get_latest_cid(url))\r\n            seq_num = latest_node.seq_num + 1 if latest_node is not None else 0\r\n        except IPARONotFoundException:\r\n            seq_num = 0\r\n        iparo = IPARO(url=url, content=content, timestamp=timestamp,\r\n                      linked_iparos=set(), seq_num=seq_num)\r\n        return iparo
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPAROFactory.py b/src/iparo/IPAROFactory.py
--- a/src/iparo/IPAROFactory.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/IPAROFactory.py	(date 1744735313831)
@@ -1,15 +1,18 @@
+import os
 from datetime import datetime
 
+from warcio import ArchiveIterator
+
 from iparo.IPAROException import IPARONotFoundException
 from iparo.IPARO import IPARO
 from iparo.IPARODateFormat import IPARODateFormat
-from iparo.IPFS import ipfs
-from iparo.IPNS import ipns
+from iparo.mock.IPFS import ipfs
+from iparo.mock.IPNS import ipns
 
 
 class IPAROFactory:
     @classmethod
-    def create_node(cls, url: str, content: bytes) -> IPARO:
+    def create_mock_iparo(cls, url: str, content: bytes) -> IPARO:
         timestamp = datetime.strftime(datetime.now(), IPARODateFormat.DATE_FORMAT)
         try:
             latest_node = ipfs.retrieve(ipns.get_latest_cid(url))
@@ -18,4 +21,41 @@
             seq_num = 0
         iparo = IPARO(url=url, content=content, timestamp=timestamp,
                       linked_iparos=set(), seq_num=seq_num)
-        return iparo
\ No newline at end of file
+        return iparo
+
+    @classmethod
+    def create_iparo(cls, url: str, content: bytes) -> IPARO:
+        timestamp = datetime.strftime(datetime.now(), IPARODateFormat.DATE_FORMAT)
+        try:
+            latest_node = IPFS.retrieve(ipns.get_latest_cid(url))
+            seq_num = latest_node.seq_num + 1 if latest_node is not None else 0
+        except IPARONotFoundException:
+            seq_num = 0
+        iparo = IPARO(url=url, content=content, timestamp=timestamp,
+                      linked_iparos=set(), seq_num=seq_num)
+        return iparo
+
+    @classmethod
+    def from_warc_file(cls, current_dir=None, filename=None) -> IPARO:
+        """Processes WARC file, creates IPARO objects, and pushes them to IPFS and IPNS."""
+        if current_dir is None:
+            current_dir = os.path.dirname(os.path.abspath(__file__))
+            current_dir = os.path.join(current_dir, '..', 'samples', 'warcs')
+
+        warc_path = os.path.join(current_dir, filename)
+        with open(warc_path, 'rb') as stream:
+            for record in ArchiveIterator(stream):
+                if record.rec_type == 'response':
+                    url = record.rec_headers.get_header('WARC-Target-URI')
+                    timestamp = record.rec_headers.get_header('WARC-Date')
+                    content = record.content_stream().read()
+
+                    iparo_object = IPARO(
+                        url=url,
+                        timestamp=timestamp,
+                        seq_num=0,
+                        linked_iparos=set(),
+                        content=content,
+                        nonce=0
+                    )
+                    return iparo_object
\ No newline at end of file
Index: src/iparo/LinkingStrategy.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nfrom abc import abstractmethod, ABC\r\nfrom datetime import timedelta\r\nfrom math import floor\r\n\r\nfrom iparo.IPARODateFormat import IPARODateFormat\r\nfrom iparo.IPAROLink import IPAROLink\r\nfrom iparo.IPAROLinkFactory import IPAROLinkFactory\r\nfrom iparo.IPFS import ipfs, Mode\r\nfrom iparo.IPNS import ipns\r\n\r\n\r\n# Make package/renaming with __init__ file\r\n\r\nclass LinkingStrategy(ABC):\r\n    \"\"\"\r\n    The linking strategy determines how the new IPARO is to be linked. The IPARO\r\n    object is first linked using the linking strategy, created (with the links),\r\n    and then finally stored.\r\n    \"\"\"\r\n\r\n    @abstractmethod\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        pass\r\n\r\n\r\nclass SingleStrategy(LinkingStrategy):\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_cid = ipns.get_latest_cid(url)\r\n        return {IPAROLinkFactory.from_cid(latest_cid)}\r\n\r\n\r\nclass ComprehensiveStrategy(LinkingStrategy):\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_node_links, latest_link, _ = IPAROLinkFactory.get_latest_node_links(url)\r\n        latest_node_links.add(latest_link)\r\n\r\n        return latest_node_links\r\n\r\n\r\nclass KPreviousStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, k: int):\r\n        self.k = k\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        linked_iparos, latest_link, latest_iparo = IPAROLinkFactory.get_latest_node_links(url)\r\n\r\n        seq_num_to_drop = max(latest_link.seq_num - self.k, 0)\r\n        if seq_num_to_drop > 0:\r\n            iparo_link_to_drop = ipfs.retrieve_nth_iparo(seq_num_to_drop, latest_link)\r\n            linked_iparos.remove(iparo_link_to_drop)\r\n\r\n        return linked_iparos\r\n\r\n\r\nclass PreviousStrategy(KPreviousStrategy):\r\n\r\n    def __init__(self):\r\n        super().__init__(1)\r\n\r\n\r\nclass KRandomStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, k: int):\r\n        self.k = k\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_node_links, latest_link, latest_iparo = IPAROLinkFactory.get_latest_node_links(url)\r\n\r\n        num_nodes = latest_link.seq_num\r\n        if num_nodes <= self.k:\r\n            latest_node_links.add(latest_link)\r\n            return latest_node_links\r\n        else:\r\n            # K random sequence numbers from 1 to n-1, n = latest sequence number\r\n            candidate_seq_nums = set(random.sample(range(1, num_nodes), min(self.k, num_nodes - 1)))\r\n            candidate_seq_nums.add(0)\r\n            links = IPAROLinkFactory.from_indices(latest_link, set(candidate_seq_nums))\r\n        links.add(latest_link)\r\n        return links\r\n\r\n\r\nclass SequentialExponentialStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, k: float):\r\n        self.k = k\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_link = ipfs.get_latest_link(url)\r\n        node_num = latest_link.seq_num\r\n        indices: set[int] = {0, node_num}\r\n        index = 1.0\r\n        while index < node_num + 1:\r\n            indices.add(node_num - floor(index - 1))\r\n            index *= self.k\r\n        links = IPAROLinkFactory.from_indices(latest_link, indices)\r\n        return links\r\n\r\n\r\nclass SequentialUniformNPriorStrategy(LinkingStrategy):\r\n\r\n    def __init__(self, n: int):\r\n        self.n = n\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        latest_link, latest_iparo = IPAROLinkFactory.get_link_to_latest_node(url)\r\n        indices: set[int] = {latest_iparo.seq_num * i // (self.n + 1) for i in range(self.n + 2)}\r\n        return IPAROLinkFactory.from_indices(latest_link, indices)\r\n\r\n\r\nclass SequentialSMaxGapStrategy(LinkingStrategy):\r\n\r\n    # s: the number of hops allowed between linked nodes.\r\n    def __init__(self, s: int):\r\n        self.s = s\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n\r\n        # Sequentially add nodes with no more than S hops between them\r\n        start_seq_num = latest_link.seq_num - self.s\r\n\r\n        # range(start, 0, -s) -> From start to 0 (exclusive), going down in step of size s.\r\n        node_indices = set(range(start_seq_num, 0, -self.s))\r\n        links = IPAROLinkFactory.from_indices(latest_link, node_indices)\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n\r\n        return links\r\n\r\n\r\nclass TemporallyUniformStrategy(LinkingStrategy):\r\n    def __init__(self, n: int):\r\n        self.n = n  # Number of uniformly distributed links to create\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        # Get Latest Link and Latest CID in one fell swoop\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n        time_window = IPARODateFormat.diff(latest_link.timestamp, first_link.timestamp)\r\n        first_ts = first_link.timestamp\r\n        # Adds nodes sequenced as 1, 2, ..., n-1\r\n        timestamps = set(IPARODateFormat.add_timedeltas(first_ts,\r\n                                                        [i * time_window / self.n for i in range(1, self.n)]))\r\n        links, _ = IPAROLinkFactory.from_timestamps(latest_link, {first_link, latest_link}, timestamps)\r\n\r\n        # Add latest and first links.\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n\r\n        return links\r\n\r\n\r\nclass TemporallyMaxGapStrategy(LinkingStrategy):\r\n    def __init__(self, max_gap: timedelta):\r\n        self.max_gap = max_gap\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n        curr_link = latest_link\r\n        current_time = latest_link.timestamp\r\n        known_links = {first_link, latest_link}\r\n\r\n        links = set()\r\n        # Keep stepping back using max_gap\r\n        while curr_link.seq_num > 0:\r\n            current_time = IPARODateFormat.add_timedelta(current_time, -self.max_gap)\r\n            curr_link, known_links = ipfs.retrieve_closest_iparo(curr_link, known_links,\r\n                                                                 current_time, Mode.LATEST_BEFORE)\r\n            links.add(curr_link)\r\n\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n        return links\r\n\r\n\r\nclass TemporallyExponentialStrategy(LinkingStrategy):\r\n    def __init__(self, base: float, time_unit: timedelta):\r\n        self.base = base\r\n        self.time_unit = time_unit\r\n\r\n    def get_candidate_nodes(self, url: str) -> set[IPAROLink]:\r\n        # Assume num_nodes > 1\r\n        first_link, latest_link, latest_iparo = IPAROLinkFactory.get_links_to_first_and_latest_nodes(url)\r\n\r\n        # Exponential time gaps\r\n        gap = self.time_unit\r\n        time_window = IPARODateFormat.diff(latest_iparo.timestamp, first_link.timestamp)\r\n        gaps = []\r\n        while gap < time_window:\r\n            gaps.append(-gap)\r\n            gap *= self.base\r\n        gaps.reverse()\r\n\r\n        timestamps = IPARODateFormat.add_timedeltas(latest_iparo.timestamp, gaps)\r\n        links, _ = IPAROLinkFactory.from_timestamps(latest_link, {first_link, latest_link}, timestamps)\r\n        links.add(first_link)\r\n        links.add(latest_link)\r\n\r\n        return links\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/LinkingStrategy.py b/src/iparo/LinkingStrategy.py
--- a/src/iparo/LinkingStrategy.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/src/iparo/LinkingStrategy.py	(date 1744735162781)
@@ -6,8 +6,8 @@
 from iparo.IPARODateFormat import IPARODateFormat
 from iparo.IPAROLink import IPAROLink
 from iparo.IPAROLinkFactory import IPAROLinkFactory
-from iparo.IPFS import ipfs, Mode
-from iparo.IPNS import ipns
+from iparo.mock.IPFS import ipfs, Mode
+from iparo.mock.IPNS import ipns
 
 
 # Make package/renaming with __init__ file
@@ -89,8 +89,8 @@
         self.k = k
 
     def get_candidate_nodes(self, url: str) -> set[IPAROLink]:
-        latest_link = ipfs.get_latest_link(url)
-        node_num = latest_link.seq_num
+        latest_link, latest_iparo = IPAROLinkFactory.get_link_to_latest_node(url)
+        node_num = latest_iparo.seq_num
         indices: set[int] = {0, node_num}
         index = 1.0
         while index < node_num + 1:
Index: test/IPAROTest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\r\n\r\nfrom iparo.IPAROFactory import IPAROFactory\r\nfrom IPAROTestConstants import *\r\n\r\n\r\nclass IPAROObjectTest(unittest.TestCase):\r\n\r\n    def test_has_content(self):\r\n        content = iparo1.content\r\n        self.assertIsInstance(content, bytes)\r\n        self.assertEqual(content, b\"123456\")\r\n\r\n    def test_has_timestamp(self):\r\n        timestamp = iparo1.timestamp\r\n        self.assertIsInstance(timestamp, str)\r\n        self.assertEqual(timestamp, datetime.strftime(time1, IPARODateFormat.DATE_FORMAT))\r\n\r\n    def test_has_linked_nodes(self):\r\n        linked_nodes = iparo1.linked_iparos\r\n        self.assertSetEqual(linked_nodes, set())\r\n\r\n    def test_has_url(self):\r\n        url = iparo1.url\r\n        self.assertIsInstance(url, str)\r\n        self.assertEqual(url, URL)\r\n\r\n    def test_can_be_serialized(self):\r\n        self.assertIsInstance(str(iparo1), str)\r\n\r\n\r\nclass IPAROFactoryTest(unittest.TestCase):\r\n\r\n    def setUp(self):\r\n        self.iparo = IPAROFactory.create_node(URL, b\"123456\")\r\n        self.iparo2 = IPAROFactory.create_node(URL2, b\"1234567\")\r\n\r\n    def test_url_is_correct(self):\r\n        self.assertEqual(self.iparo.url, URL)\r\n        self.assertEqual(self.iparo2.url, URL2)\r\n\r\n    def test_content_is_correct(self):\r\n        self.assertEqual(self.iparo.content, b\"123456\")\r\n        self.assertEqual(self.iparo2.content, b\"1234567\")\r\n\r\n    def test_date_is_correct(self):\r\n        self.assertGreaterEqual(datetime.now(), datetime.strptime(self.iparo.timestamp, IPARODateFormat.DATE_FORMAT))\r\n        self.assertGreaterEqual(datetime.now(), datetime.strptime(self.iparo2.timestamp, IPARODateFormat.DATE_FORMAT))\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/IPAROTest.py b/test/IPAROTest.py
--- a/test/IPAROTest.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/test/IPAROTest.py	(date 1744735162832)
@@ -32,8 +32,8 @@
 class IPAROFactoryTest(unittest.TestCase):
 
     def setUp(self):
-        self.iparo = IPAROFactory.create_node(URL, b"123456")
-        self.iparo2 = IPAROFactory.create_node(URL2, b"1234567")
+        self.iparo = IPAROFactory.create_mock_iparo(URL, b"123456")
+        self.iparo2 = IPAROFactory.create_mock_iparo(URL2, b"1234567")
 
     def test_url_is_correct(self):
         self.assertEqual(self.iparo.url, URL)
Index: test/IPAROTestHelpers.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from iparo import IPARO\r\nfrom IPAROTestConstants import *\r\nfrom iparo.IPFS import *\r\nfrom iparo.LinkingStrategy import *\r\nfrom iparo.IPAROFactory import IPAROFactory\r\n\r\n\r\ndef add_nodes(num_nodes: int):\r\n    iparos = []\r\n    for i in range(num_nodes):\r\n        content = generate_random_content_string()\r\n        try:\r\n            linked_iparos = SingleStrategy().get_candidate_nodes(URL)\r\n            # todo add specific exception.\r\n        except Exception:\r\n            linked_iparos = set()\r\n        timestamp = time1 + timedelta(seconds=10 * i)\r\n        iparo = IPARO(content=content, timestamp=datetime.strftime(timestamp, IPARODateFormat.DATE_FORMAT),\r\n                      url=URL, linked_iparos=linked_iparos, seq_num=i)\r\n        iparos.append(iparo)\r\n        cid = ipfs.store(iparo)\r\n\r\n        ipns.update(URL, cid)\r\n    return iparos\r\n\r\n\r\ndef generate_random_content_string() -> bytes:\r\n    # Contains all printable characters in the original ASCII format, which are represented by codes from 32 to 126.\r\n    contents = bytes([random.randint(32, 126) for _ in range(100)])\r\n    return contents\r\n\r\n\r\ndef test_strategy(strategy: LinkingStrategy) -> list[int]:\r\n    lengths = []\r\n    for i in range(100):\r\n        content = generate_random_content_string()\r\n        try:\r\n            linked_iparos = strategy.get_candidate_nodes(URL)\r\n        except IPARONotFoundException:\r\n            linked_iparos = set()\r\n        lengths.append(len(linked_iparos))\r\n        timestamp = datetime.strftime(time1 + timedelta(seconds=i), IPARODateFormat.DATE_FORMAT)\r\n        iparo = IPARO(content=content, timestamp=timestamp,\r\n                      url=URL, linked_iparos=linked_iparos, seq_num=i)\r\n        cid = ipfs.store(iparo)\r\n        ipns.update(URL, cid)\r\n    return lengths\r\n\r\n\r\ndef test_strategy_verbose(strategy: LinkingStrategy) -> tuple[list[int], list[str], list[IPARO]]:\r\n    lengths = []\r\n    cids = []\r\n    iparos = []\r\n    for i in range(100):\r\n        content = generate_random_content_string()\r\n        try:\r\n            linked_iparos = strategy.get_candidate_nodes(URL)\r\n        except IPARONotFoundException:\r\n            linked_iparos = set()\r\n        timestamp = datetime.strftime(time1 + timedelta(seconds=i), IPARODateFormat.DATE_FORMAT)\r\n        iparo = IPARO(content=content, timestamp=timestamp, url=URL, linked_iparos=linked_iparos, seq_num=i)\r\n        cid = ipfs.store(iparo)\r\n        ipns.update(URL, cid)\r\n        iparos.append(iparo)\r\n        cids.append(cid)\r\n        lengths.append(len(linked_iparos))\r\n    return lengths, cids, iparos\r\n\r\n\r\ndef test_strategy_with_time_distribution(strategy: LinkingStrategy, relative_times: list[int]) -> list[datetime]:\r\n    \"\"\"\r\n    :param strategy: The strategy to test\r\n    :param relative_times: The times relative to the first node in seconds.\r\n    :return: A list of timestamps that are connected to the latest node by the linking strategy.\r\n    \"\"\"\r\n    for i, dt in enumerate(relative_times):\r\n        content = generate_random_content_string()\r\n        timestamp = datetime.strftime(time1 + timedelta(seconds=dt), IPARODateFormat.DATE_FORMAT)\r\n        iparo = IPAROFactory.create_node(URL, content)\r\n        iparo.timestamp = timestamp\r\n        iparo.seq_num = i\r\n        try:\r\n            iparo.linked_iparos = strategy.get_candidate_nodes(URL)\r\n        except IPARONotFoundException:\r\n            pass\r\n        cid = ipfs.store(iparo)\r\n        ipns.update(URL, cid)\r\n\r\n    # Where would the next link go?\r\n    links = strategy.get_candidate_nodes(URL)\r\n    time = time1.strftime(IPARODateFormat.DATE_FORMAT)\r\n\r\n    return sorted([IPARODateFormat.diff(link.timestamp, time) / timedelta(seconds=1) for link in links])\r\n\r\n\r\ndef test_closest_iparo(rel_time: timedelta):\r\n    \"\"\"\r\n    Helper method for testing what the closest IPARO is to the given relative time.\r\n    \"\"\"\r\n    cid = ipns.get_latest_cid(URL)\r\n    latest_iparo = ipfs.retrieve(cid)\r\n    link = IPAROLinkFactory.from_cid_iparo(cid, latest_iparo)\r\n    timestamp = IPARODateFormat.add_timedelta(link.timestamp, rel_time)\r\n    observed_iparo, _ = ipfs.retrieve_closest_iparo(link, {link}, timestamp)\r\n\r\n    return observed_iparo.seq_num\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/IPAROTestHelpers.py b/test/IPAROTestHelpers.py
--- a/test/IPAROTestHelpers.py	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/test/IPAROTestHelpers.py	(date 1744735162848)
@@ -1,6 +1,6 @@
 from iparo import IPARO
 from IPAROTestConstants import *
-from iparo.IPFS import *
+from iparo.ipfs.IPFS import *
 from iparo.LinkingStrategy import *
 from iparo.IPAROFactory import IPAROFactory
 
@@ -76,7 +76,7 @@
     for i, dt in enumerate(relative_times):
         content = generate_random_content_string()
         timestamp = datetime.strftime(time1 + timedelta(seconds=dt), IPARODateFormat.DATE_FORMAT)
-        iparo = IPAROFactory.create_node(URL, content)
+        iparo = IPAROFactory.create_mock_iparo(URL, content)
         iparo.timestamp = timestamp
         iparo.seq_num = i
         try:
@@ -93,6 +93,20 @@
     return sorted([IPARODateFormat.diff(link.timestamp, time) / timedelta(seconds=1) for link in links])
 
 
+def retrieve_iparo_by_url_and_number(url: str, number: int) -> IPAROLink:
+    """
+    Retrieves the IPARO CID corresponding to a given sequence number and a URL.
+    Usually only used for tests.
+    """
+    cid = ipns.get_latest_cid(url)
+
+    # To avoid a circular dependency on IPAROLinkFactory
+    iparo = self.retrieve(cid)
+    link = IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)
+    result = self.retrieve_nth_iparo(number, link)
+    return result
+
+
 def test_closest_iparo(rel_time: timedelta):
     """
     Helper method for testing what the closest IPARO is to the given relative time.
Index: src/iparo/mock/IPFS.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/mock/IPFS.py b/src/iparo/mock/IPFS.py
new file mode 100644
--- /dev/null	(date 1744735188442)
+++ b/src/iparo/mock/IPFS.py	(date 1744735188442)
@@ -0,0 +1,163 @@
+import hashlib
+import pickle
+
+from iparo.IPAROException import IPARONotFoundException
+from iparo.IPARO import IPARO
+from iparo.IPARODateFormat import IPARODateFormat, Mode
+from iparo.IPAROLink import IPAROLink
+from iparo.mock.IPNS import ipns
+
+
+class MockIPFS:
+    """
+    The InterPlanetary File System is responsible for hashing, storing,
+    retrieving, and linking IPARO objects.
+    """
+
+    def __init__(self):
+        self.data: dict[str, bytes] = {}
+        self.retrieve_count = 0
+        self.store_count = 0
+
+    def store(self, iparo: IPARO) -> str:
+        """
+        Stores a node with its CID.
+
+        Args:
+            iparo (IPARO): The IPARO object to store.
+
+        Returns:
+            The CID of the newly stored IPARO.
+        """
+        iparo_bytes = pickle.dumps(iparo)
+        sha256_hash = hashlib.sha256(iparo_bytes).hexdigest()
+        cid = 'Qm' + sha256_hash[:34]
+        self.store_count += 1
+        self.data[cid] = iparo_bytes
+        return cid
+
+    def reset_data(self):
+        self.data: dict[str, IPARO] = {}
+
+    def retrieve(self, cid) -> IPARO:
+        """
+        Retrieves the IPARO object corresponding to a given CID, if it exists;
+        otherwise, it throws an IPARONotFoundException.
+        """
+        self.retrieve_count += 1
+        if cid not in self.data:
+            raise IPARONotFoundException(cid)
+        iparo_bytes = self.data[cid]
+        return pickle.loads(iparo_bytes)
+
+    def retrieve_by_url_and_timestamp(self, url: str, target_timestamp: str, mode: Mode = Mode.LATEST_BEFORE) -> \
+            IPAROLink:
+        # To avoid circular dependencies.
+        cid = ipns.get_latest_cid(url)
+        iparo = ipfs.retrieve(cid)
+        latest_link = IPAROLink(cid=cid, seq_num=iparo.seq_num, timestamp=iparo.timestamp)
+        link, _ = self.retrieve_closest_iparo(latest_link, set(), target_timestamp, mode)
+        return link
+
+    def retrieve_nth_iparo(self, number: int, link: IPAROLink) -> IPAROLink:
+        """
+        A helper method that enables the retrieval of IPARO using a sequence number
+        to save IPARO operations by adding the ability to repeatedly apply the
+        greedy search method.
+        """
+        if link.seq_num < number:
+            raise IPARONotFoundException(number)
+        elif link.seq_num == number:
+            return link
+
+        # It is assumed that there is a link to the previous node.
+        iparo = self.retrieve(link.cid)
+        candidate_links = [link for link in iparo.linked_iparos if link.seq_num >= number]
+        if not candidate_links:
+            raise IPARONotFoundException(number)
+        next_link = min(candidate_links, key=lambda link: link.seq_num)
+
+        return self.retrieve_nth_iparo(number, next_link)
+
+    def retrieve_closest_iparo(self, curr_link: IPAROLink, known_links: set[IPAROLink], timestamp: str,
+                               mode: Mode = Mode.CLOSEST)\
+            -> tuple[IPAROLink, set[IPAROLink]]:
+        """
+        A helper method that enables the retrieval of IPARO using a sequence number
+        to save IPARO operations by adding the ability to repeatedly apply the
+        greedy search method from an IPARO link. Unlike the other method, it only finds
+        the closest IPARO.
+        """
+
+        curr_ts = curr_link.timestamp
+
+        try:
+            # If current link has the exact timestamp or the current link is the first link:
+            if curr_ts == timestamp or curr_link.seq_num == 0:
+                return curr_link, known_links
+            prev_link = self.retrieve_nth_iparo(curr_link.seq_num - 1, curr_link)
+            prev_ts = prev_link.timestamp
+            # Calculate time fraction.
+            time_frac = IPARODateFormat.diff(timestamp, prev_ts) / IPARODateFormat.diff(curr_ts, prev_ts)
+            if time_frac >= 0:
+                if mode == Mode.CLOSEST:
+                    chosen_link = prev_link if time_frac <= 0.5 else curr_link
+                elif mode == Mode.EARLIEST_AFTER:
+                    chosen_link = curr_link if time_frac > 0 else prev_link
+                else:
+                    chosen_link = prev_link if time_frac < 1 else curr_link
+                return chosen_link, known_links
+
+            # Go over known links...
+            iparo = self.retrieve(prev_link.cid)
+
+            candidate_links = iparo.linked_iparos
+            candidate_links.add(prev_link)
+
+            known_links.update(candidate_links)
+
+            # Find minimum time greater than the timestamp.
+            next_link = min({link for link in known_links if link.timestamp > timestamp},
+                            key=lambda link: link.timestamp)
+            return self.retrieve_closest_iparo(next_link, known_links, timestamp, mode)
+        except IPARONotFoundException as e:
+            raise e
+
+    def get_counts(self) -> dict:
+        """
+        Returns the number of store, and retrieve operations performed.
+
+        Returns:
+            dict: Dictionary with counts of store, and retrieve operations.
+        """
+        counts = {"store": self.store_count, "retrieve": self.retrieve_count}
+        return counts
+
+    def reset_counts(self):
+        """
+        Resets the operation counters.
+        """
+        self.store_count = 0
+        self.retrieve_count = 0
+
+    def get_all_iparos(self, url: str) -> list[IPARO]:
+        """
+        Retrieves the list of all IPAROs in the IPFS, corresponding to the given URL.
+        The nodes are sorted from latest to earliest. This will also include all the CIDs.
+        """
+        iparos = []
+        try:
+            cid = ipns.get_latest_cid(url)
+            while True:
+                iparo = self.retrieve(cid)
+                iparos.append(iparo)
+
+                links = [link for link in iparo.linked_iparos if link.seq_num == iparo.seq_num - 1]
+                if len(links) == 0:
+                    raise IPARONotFoundException()
+                cid = links[0].cid
+        finally:
+            return iparos
+
+
+ipfs = MockIPFS()
Index: src/iparo/IPFSBase.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/IPFSBase.py b/src/iparo/IPFSBase.py
new file mode 100644
--- /dev/null	(date 1744735162858)
+++ b/src/iparo/IPFSBase.py	(date 1744735162858)
@@ -0,0 +1,7 @@
+
+
+class IPFSBase:
+    """
+    An interface for .
+    """
+    pass
\ No newline at end of file
Index: src/iparo/mock/IPNS.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iparo/mock/IPNS.py b/src/iparo/mock/IPNS.py
new file mode 100644
--- /dev/null	(date 1744735162839)
+++ b/src/iparo/mock/IPNS.py	(date 1744735162839)
@@ -0,0 +1,99 @@
+from datetime import datetime
+
+from iparo.IPAROException import IPARONotFoundException
+from iparo.IPARODateFormat import IPARODateFormat
+
+
+class MockIPNS:
+
+    def __init__(self):
+        """
+        Initialize the IPNS object with an empty hashmap for storing CIDs
+        and counters for tracking operations.
+        """
+        self.__store: dict[str, str] = {}
+        self.__versions: dict[tuple[str, str], str] = {}
+        self.update_count = 0
+        self.get_count = 0
+
+    # Add parameter datetime - str
+    def update(self, url: str, cid: str, timestamp: str = 'latest'):
+        """
+        Updates the latest CID for a given URL with a given timestamp.
+
+        Args:
+            url (str): The URL of the website.
+            cid (str): The CID of the latest capture.
+            timestamp (str): The string containing the timestamp (YYYY-mm-dd hh:mm:ss).
+            Default is latest.
+        """
+        self.update_count += 1
+        curr_timestamp = datetime.strftime(datetime.now(), IPARODateFormat.DATE_FORMAT)\
+            if timestamp == 'latest' else timestamp
+
+        # /archive/latest/{url} -> value of URL, map it to the CID [default]
+        self.__store[url] = cid
+
+        # /archive/{datetime}/{url} -> convert datetime, map it to the CID
+        self.__versions[(url, curr_timestamp)] = cid
+
+    # Optional parameter: datetime ([un]serialized), default value is latest.
+    def get_latest_cid(self, url: str) -> str:
+        """
+        Retrieves the latest CID for a given URL if it exists, else None.
+
+        Args:
+            url (str): The URL of the website.
+
+        Returns:
+            str: The CID of the latest capture for the given URL if it exists, else None.
+
+        Exceptions:
+            EmptyError: If the URL is not found.
+        """
+        self.get_count += 1
+        if url not in self.__store:
+            raise IPARONotFoundException(url)
+        return self.__store[url]
+
+    def get_cid(self, url: str, timestamp: str) -> str:
+        """
+        Retrieves the CID for a given timestamp.
+
+        Args:
+            url (str): The URL of the website.
+            timestamp (str): The 14-character-long timestamp for the
+
+        Returns:
+            str: The CID of the latest capture for the given URL if it exists, else None.
+        """
+        self.get_count += 1
+        return self.__versions[(url, timestamp)]
+
+    def get_counts(self):
+        """
+        Returns the number of update and get operations performed.
+
+        Returns:
+            dict: Dictionary with the counts of update and get operations.
+        """
+        return {"get": self.get_count, "update": self.update_count}
+
+    def reset_data(self):
+        """
+        Resets the data.
+        """
+        self.__store: dict[str, str] = {}
+
+    def reset_counts(self):
+        """
+        Resets the operating counts. Used for the evaluation phase.
+        """
+        self.update_count = 0
+        self.get_count = 0
+
+    def get_store(self):
+        return self.__store
+
+
+ipns = MockIPNS()
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"9288c70e-2960-4e90-a337-b37f2cbbb71f\" name=\"Changes\" comment=\"\">\r\n      <change afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/src/iparo/IPARODateFormat.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/Exceptions.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/Exceptions.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPARODateConverter.py\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPAROFactory.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPAROFactory.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPAROSimulation.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPAROSimulation.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPFS.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPFS.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/IPNS.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/IPNS.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/LinkingStrategy.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/LinkingStrategy.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/VersionDensity.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/VersionDensity.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/iparo/__init__.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/iparo/__init__.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROSimulationTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROSimulationTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROStrategyTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROStrategyTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROTestConstants.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROTestConstants.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPAROTestHelpers.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPAROTestHelpers.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPFSTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPFSTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/IPNSTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/IPNSTest.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/VersionDensityTest.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/VersionDensityTest.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 4\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2uAmi4QeLGK4nnUyUY2ww85A6zf\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest.executor\": \"Run\",\r\n    \"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.executor\": \"Run\",\r\n    \"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node.executor\": \"Run\",\r\n    \"Python tests.Python tests for VersionDensityTest.VersionDensityTestCase.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPAROStrategyTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPAROTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPFSTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in IPNSTest.py.executor\": \"Run\",\r\n    \"Python tests.Python tests in test.executor\": \"Run\",\r\n    \"Python tests.Unittests for IPFSTest.IPAROLinkFactoryTest.test_can_raise_exception_if_timestamp_goes_after_latest_timestamp.executor\": \"Debug\",\r\n    \"Python tests.Unittests for IPFSTest.IPAROLinkFactoryTest.test_can_retrieve_by_timestamp_on_first_prior_node.executor\": \"Run\",\r\n    \"Python.IPAROSimulation.executor\": \"Run\",\r\n    \"Python.MasterTest.executor\": \"Run\",\r\n    \"Python.app.executor\": \"Run\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"ptl46\",\r\n    \"last_opened_file_path\": \"C:/Users/patri/OneDrive/Documents/GitHub/iparo/backend/src/iparo/IPFS.py\",\r\n    \"settings.editor.selected.configurable\": \"editor.preferences.fonts.default\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\" selected=\"Python.MasterTest\">\r\n    <configuration name=\"MasterTest\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/test/MasterTest.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"PythonConfigurationType\" factoryName=\"Python\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"Tox\" factoryName=\"Tox\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Docutils task\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Sphinx task\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for IPAROSimulationTest.IPAROSimulationTest\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;IPAROSimulationTest.IPAROSimulationTest&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for IPAROStrategyTest.IPAROStrategyTest\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;IPAROStrategyTest.IPAROStrategyTest&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Python tests for VersionDensityTest.VersionDensityTestCase\" type=\"tests\" factoryName=\"Autodetect\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"backend\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;VersionDensityTest.VersionDensityTestCase&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PYTHON&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.MasterTest\" />\r\n        <item itemvalue=\"Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest\" />\r\n        <item itemvalue=\"Python tests.Python tests for VersionDensityTest.VersionDensityTestCase\" />\r\n        <item itemvalue=\"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest\" />\r\n        <item itemvalue=\"Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-50da183f06c8-d3b881c8e49f-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-233.13135.95\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"9288c70e-2960-4e90-a337-b37f2cbbb71f\" name=\"Changes\" comment=\"\" />\r\n      <created>1742230161614</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1742230161614</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/test/IPAROTestHelpers.py</url>\r\n          <line>103</line>\r\n          <option name=\"timeStamp\" value=\"5\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/test/IPAROTestHelpers.py</url>\r\n          <line>89</line>\r\n          <option name=\"timeStamp\" value=\"12\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 3f79d25e90512bd0faba0c60c06b42641acfb44f)
+++ b/.idea/workspace.xml	(date 1744735209405)
@@ -5,26 +5,24 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="9288c70e-2960-4e90-a337-b37f2cbbb71f" name="Changes" comment="">
-      <change afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/iparo/IPARODateFormat.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/Exceptions.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/Exceptions.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/IPARODateConverter.py" beforeDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/iparo/IPFSBase.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/iparo/mock/IPFS.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/iparo/mock/IPNS.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/iparo/mock/__init__.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/app.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/app.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/iparo/IPARODateFormat.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPARODateFormat.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/IPAROFactory.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPAROFactory.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPAROLinkFactory.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/IPAROSimulation.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPAROSimulation.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/IPFS.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPFS.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/IPNS.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/IPNS.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/LinkingStrategy.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/LinkingStrategy.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/iparo/VersionDensity.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/VersionDensity.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/iparo/__init__.py" beforeDir="false" afterPath="$PROJECT_DIR$/src/iparo/__init__.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/test/IPAROSimulationTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROSimulationTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPAROStrategyTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROStrategyTest.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/test/IPAROTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPAROTestConstants.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROTestConstants.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/test/IPAROTestHelpers.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPAROTestHelpers.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/test/IPFSTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPFSTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/IPNSTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/IPNSTest.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/VersionDensityTest.py" beforeDir="false" afterPath="$PROJECT_DIR$/test/VersionDensityTest.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -39,6 +37,11 @@
     </option>
   </component>
   <component name="Git.Settings">
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$/.." value="ptl46" />
+      </map>
+    </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
   </component>
   <component name="ProjectColorInfo">{
@@ -66,12 +69,20 @@
     "Python.MasterTest.executor": "Run",
     "Python.app.executor": "Run",
     "RunOnceActivity.OpenProjectViewOnStart": "true",
-    "git-widget-placeholder": "ptl46",
+    "git-widget-placeholder": "qb42",
     "last_opened_file_path": "C:/Users/patri/OneDrive/Documents/GitHub/iparo/backend/src/iparo/IPFS.py",
     "settings.editor.selected.configurable": "editor.preferences.fonts.default"
   }
 }]]></component>
-  <component name="RunManager" selected="Python.MasterTest">
+  <component name="RecentsManager">
+    <key name="MoveFile.RECENT_KEYS">
+      <recent name="C:\Users\patri\OneDrive\Documents\GitHub\iparo\backend\src\iparo" />
+      <recent name="C:\Users\patri\OneDrive\Documents\GitHub\iparo\backend\src\iparo\mock" />
+      <recent name="C:\Users\patri\OneDrive\Documents\GitHub\iparo\backend\src\iparo\ipns" />
+      <recent name="C:\Users\patri\OneDrive\Documents\GitHub\iparo\backend\src\iparo\ipfs" />
+    </key>
+  </component>
+  <component name="RunManager" selected="Python.app">
     <configuration name="MasterTest" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="backend" />
       <option name="ENV_FILES" value="" />
@@ -94,7 +105,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration default="true" type="PythonConfigurationType" factoryName="Python">
+    <configuration name="app" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="backend" />
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -103,11 +114,11 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/src" />
+      <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/src/app.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -116,52 +127,6 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration default="true" type="Tox" factoryName="Tox">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <method v="2" />
-    </configuration>
-    <configuration default="true" type="docs" factoryName="Docutils task">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="docutils_input_file" value="" />
-      <option name="docutils_output_file" value="" />
-      <option name="docutils_params" value="" />
-      <option name="docutils_task" value="" />
-      <option name="docutils_open_in_browser" value="false" />
-      <method v="2" />
-    </configuration>
-    <configuration default="true" type="docs" factoryName="Sphinx task">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="docutils_input_file" value="" />
-      <option name="docutils_output_file" value="" />
-      <option name="docutils_params" value="" />
-      <option name="docutils_task" value="" />
-      <option name="docutils_open_in_browser" value="false" />
-      <method v="2" />
-    </configuration>
     <configuration name="Python tests for IPAROSimulationTest.IPAROSimulationTest" type="tests" factoryName="Autodetect" temporary="true" nameIsGenerated="true">
       <module name="backend" />
       <option name="ENV_FILES" value="" />
@@ -192,21 +157,6 @@
       <option name="_new_targetType" value="&quot;PYTHON&quot;" />
       <method v="2" />
     </configuration>
-    <configuration name="Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node" type="tests" factoryName="Autodetect" temporary="true" nameIsGenerated="true">
-      <module name="backend" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/test" />
-      <option name="IS_MODULE_SDK" value="true" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="_new_additionalArguments" value="&quot;&quot;" />
-      <option name="_new_target" value="&quot;IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node&quot;" />
-      <option name="_new_targetType" value="&quot;PYTHON&quot;" />
-      <method v="2" />
-    </configuration>
     <configuration name="Python tests for VersionDensityTest.VersionDensityTestCase" type="tests" factoryName="Autodetect" temporary="true" nameIsGenerated="true">
       <module name="backend" />
       <option name="ENV_FILES" value="" />
@@ -224,11 +174,11 @@
     </configuration>
     <recent_temporary>
       <list>
-        <item itemvalue="Python.MasterTest" />
-        <item itemvalue="Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest" />
+        <item itemvalue="Python.app" />
         <item itemvalue="Python tests.Python tests for VersionDensityTest.VersionDensityTestCase" />
         <item itemvalue="Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest" />
-        <item itemvalue="Python tests.Python tests for IPAROStrategyTest.IPAROStrategyTest.test_single_strategy_should_link_to_only_one_node" />
+        <item itemvalue="Python tests.Python tests for IPAROSimulationTest.IPAROSimulationTest" />
+        <item itemvalue="Python.MasterTest" />
       </list>
     </recent_temporary>
   </component>
diff --git a/src/iparo/mock/__init__.py b/src/iparo/mock/__init__.py
new file mode 100644
